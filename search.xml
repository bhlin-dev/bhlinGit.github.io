<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Java基础(十)]]></title>
      <url>/2017/06/14/Java%E5%9F%BA%E7%A1%80-%E5%8D%81/</url>
      <content type="html"><![CDATA[<h2 id="类加载机制与反射"><a href="#类加载机制与反射" class="headerlink" title="类加载机制与反射"></a>类加载机制与反射</h2><p>当程序主动使用某个类时，如果该类还未加载到内存中，系统会通过加载、连接、初始化三个步骤对该类进行初始化，JVM会连续完成这三个步骤，这三个步骤统称类加载或类初始化；</p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>类加载指的是将类的class文件读入内存，并为之创建一个java.lang.Class对象。类的加载有类加载器完成，类加载器通常由JVM提供也称系统类加载器。除此之外还可以通过集成ClassLoader基类自定义类加载器。<br>通过使用不同的类加载器，可以从不同的来源加载类的二进制数据:</p>
<blockquote>
<ol>
<li>从本地文件系统加载class文件；</li>
<li>从JAR包加载class文件；</li>
<li>通过网络加载class文件；</li>
<li>把一个Java源文件动态编译，并执行加载；</li>
</ol>
</blockquote>
<h3 id="类连接的过程"><a href="#类连接的过程" class="headerlink" title="类连接的过程"></a>类连接的过程</h3><p>当类被加载后，系统产生对应的Class对象，接着进入连接阶段。连接阶段负责把类的二进制数据合并到JRE中。类连接可分为如下三个阶段:</p>
<blockquote>
<ol>
<li>验证阶段: 检验被加载的类是否有正确的内部结构，并和其他类协调一致；</li>
<li>准备阶段: 负责为类的类变量分配内存，并设置默认初始值；</li>
<li>解析阶段: 将类的二进制数据中的符号引用替换成直接引用；</li>
</ol>
</blockquote>
<h3 id="类初始化的过程"><a href="#类初始化的过程" class="headerlink" title="类初始化的过程"></a>类初始化的过程</h3><p>类初始化阶段，虚拟机负责对类进行初始化，主要是对<font color="red">类变量</font>进行初始化。Java类中类变量指定初始值有两种:声明类变量指定初始值；使用静态初始化块为类变量进行初始化；<br>JVM初始化的步骤:</p>
<blockquote>
<ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>加入该类的直接父类没有被初始化，则先初始化其直接父类</li>
<li>加入类中有初始化语句，则系统一次执行这些初始化语句</li>
</ol>
</blockquote>
<p>当Java程序首次通过下面几种方式使用某个类或者接口，系统就会初始化该类或接口:</p>
<blockquote>
<ol>
<li>创建类的实例，包括使用new操作符、通过反射创建实例，通过反序列化创建实例</li>
<li>调用某个类的类方法</li>
<li>访问或赋值某个类或接口的类变量，</li>
<li>使用反射方式强制创建某个类或接口对应的java.lang.Class对象</li>
<li>初始化某个类的子类。初始化子类，会先初始化父类，一直到Object类</li>
<li>直接使用java.exe命令运行某个主类</li>
</ol>
</blockquote>
<p>对于一个final型的类变量，如果该类变量的值在编译时可以确定，Java编译器会在编译时把使用这个类变量替换成相应的值，因此程序使用该静态类变量，并不会导致类的初始化；</p>
<h3 id="类加载器以及实现机制"><a href="#类加载器以及实现机制" class="headerlink" title="类加载器以及实现机制"></a>类加载器以及实现机制</h3><p>类加载器负责加载所有的类，一旦一个类被载入JVM中，同一个类就不会被再次载入。在JVM中，一个类的全限定类名(包名和类名)和类加载器作为唯一标示。<br>当JVM启动时，会形成由三个类加载器组成的初始类加载层次结构:</p>
<blockquote>
<ol>
<li>Bootstrap ClassLoader: 根类加载器，负责加载Java的核心类，根类加载器不是java.lang.ClassLoader的子类，是由JVM自身实现；</li>
<li>Extension ClassLoader: 扩展类加载器，负责加载JRE的扩展目录中JAR包的类</li>
<li>System ClassLoader: 系统类加载器，负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器</li>
</ol>
</blockquote>
<p>JVM的类加载机制主要有如下三种:</p>
<blockquote>
<ol>
<li>全盘负责: 当一个类加载器加载某个Class时，该Class所依赖和引用的其他Class也是由该类加载器负责再付，除非显式使用另外一个类加载加载；</li>
<li>父类委托: 先让parent(父)类加载器视图加载该Class，只有父类加载器无法加载该类时，才尝试从自己的类路径加载;</li>
<li>缓存机制: 已经加载过的Class都会被缓存，当程序需要使用某个Class时，先从缓存区查找，查找不到，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区</li>
</ol>
</blockquote>
<p>除了Java提供的类加载器之外，也可以通过集成ClassLoader自定义类加载器.JVM中这4种类加载器的层次结构:<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-14-01.png" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderPropTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ClassLoader systemLoader = ClassLoader.getSystemClassLoader();</div><div class="line">        System.out.println(<span class="string">"系统类加载器:"</span> + systemLoader);</div><div class="line">        Enumeration&lt;URL&gt; eml = systemLoader.getResources(<span class="string">""</span>);</div><div class="line">        <span class="keyword">while</span> (eml.hasMoreElements()) &#123;</div><div class="line">            System.out.println(eml.nextElement());</div><div class="line">        &#125;</div><div class="line">        ClassLoader extendsionLader = systemLoader.getParent();</div><div class="line">        System.out.println(<span class="string">"扩展类加载器: "</span> + extendsionLader);</div><div class="line">        System.out.println(<span class="string">"扩展类加载的加载路径: "</span> + System.getProperty(<span class="string">"java.ext.dirs"</span>));</div><div class="line">        System.out.println(<span class="string">"扩展类加载器的parent: "</span> + extendsionLader.getParent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类加载器加载Class大致要经过如下8个步骤:</p>
<blockquote>
<ol>
<li>检测Class缓存区是否有此Class,有则进入第8步</li>
<li>如果父类加载器不存在，则进入第4步</li>
<li>使用父类加载器去载入目标，成功载入进入第8步，否则进入第5步</li>
<li>使用根类加载器载入目标类，成功载入进入第8步，否则进入第7步</li>
<li>当前类加载器尝试寻找Class文件，找到进入第6步，否则进入第8步</li>
<li>从文件中载入Class,成功载入后跳转第8步</li>
<li>抛出ClassNotFoundException异常</li>
<li>返回对应的java.lang.Class对象</li>
</ol>
</blockquote>
<h3 id="继承ClassLoader实现自定义类加载器"><a href="#继承ClassLoader实现自定义类加载器" class="headerlink" title="继承ClassLoader实现自定义类加载器"></a>继承ClassLoader实现自定义类加载器</h3><p>JVM中除了跟类加载器之外，所有的类加载器都是ClassLoader子类的实例。ClassLoader类有如下两个关键方法:</p>
<blockquote>
<ol>
<li>loadClass(String name, boolean resolve): 该方法为ClassLoader的入口点，根据指定名称来加载类，系统就是调用ClassLoader的该方法来获取指定类对应的Class对象。</li>
<li>findClass(String name): 根据指定名称来查找类</li>
</ol>
</blockquote>
<p>如果自定义ClassLoader，则可以重写以上两个方法实现，通常推荐重写findClass()方法，而不是loadClass()方法。loadClass()方法的执行步骤如下：</p>
<blockquote>
<ol>
<li>用findLoadedClass(string)检查是否已经加载类，如果已经加载直接返回</li>
<li>在父类加载器调用loadClass()方法。如果父类加载器为null，则使用根类加载器加载</li>
<li>调用finClass(String)方法查找类</li>
</ol>
</blockquote>
<p>重写findClass()方法避免覆盖默认类加载器的父类委托、缓冲机制两种策略；<br>CalssLoader还有一个核心方法，Class defineClass(String name, byte[] b, int off, int len), 该方法将指定类的字节码文件读入字节数组b内，并将它转换成Class对象，该字节码文件可以来源于文件、网络等<br>ClassLoader还包含一些普通方法:</p>
<blockquote>
<ol>
<li>findSystemClass(String name):从本地文件系统装入文件</li>
<li>static getSystemClassLoader(): 返回系统类加载器</li>
<li>getParent(): 返回类加载器的父类加载器</li>
<li>resolveClass(Class&lt;?&gt; c): 链接指定的类。类加载器可以使用此方法链接类c</li>
<li>findLoadedCladd(String name): 如果Java虚拟机已经加载名为name的类，则直接返回该类对应的Class实例，否则返回null;<h3 id="使用URLClassLoader"><a href="#使用URLClassLoader" class="headerlink" title="使用URLClassLoader"></a>使用URLClassLoader</h3>Java为ClassLoader提供一个URLClassLoader实现类，该类也是系统类加载器和扩展类加载器的父类。URLClassLoader可以从本地文件系统获取二进制文件加载类，也可以从远程主机获取二进制文件加载类。<br>URLClassLoader类提供两个构造器:</li>
<li>URLClassLoader(URL[] urls): 使用默认父类加载器创建一个实例，该实例将从urls所指定的系列路径来查询并加载类</li>
<li>URLClassLoader(URL[] urls, ClassLoader parent): 使用指定的父类加载器创建一个ClassLoader，功能和上一个一样</li>
</ol>
</blockquote>
<h3 id="使用Class对象"><a href="#使用Class对象" class="headerlink" title="使用Class对象"></a>使用Class对象</h3><p>Java程序获得Class对象通常由如下三种方式:</p>
<blockquote>
<ol>
<li>使用Class类的forName(String clazzName)静态方法。clazzName是某个类的全限定名(包名+类名)</li>
<li>调用某个类的class属性获得该类对应的Class对象。</li>
<li>调用某个对象的getClass()方法。该方法是由java.lang.Object类的方法</li>
</ol>
</blockquote>
<p>下面4个方法获取Class对应类的构造器:</p>
<blockquote>
<ol>
<li>Connstrucotr<t> getConstructor(Class&lt;?&gt;… parameterTypes): 返回Class对象类的、带指定形参列表的public构造器</t></li>
<li>Connstrucotr&lt;?&gt;[] getConstructor(): 返回Class对象所有public构造器</li>
<li>Connstrucotr<t> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes): 返回Class对象对应类的带指定形参列表的构造器，与构造器访问权限无关</t></li>
<li>Connstrucotr&lt;?&gt;[] getDeclaredConstructor(): 返回Class对象所有的构造器，与构造器访问权限无关</li>
</ol>
</blockquote>
<p>下面4个方法获取Class对应类的方法:</p>
<blockquote>
<ol>
<li>Method getMethod(String name, Class&lt;?&gt;… paramterTypes): 返回Class对应类的，带指定形参的public方法</li>
<li>Method[] getMethods(): 返回Class对应类的所有public方法</li>
<li>Method getDeclaredMethod(String name, Class&lt;?&gt;… paramterTypes): 返回Class对应类的，带指定形参的方法，与方法的访问权限无关</li>
<li>Method[] getDeclaredMethods(): 返回Class对应类的所有方法，与方法的访问权限无关</li>
</ol>
</blockquote>
<p>下面4个方法用于访问Class对应类的成员变量:</p>
<blockquote>
<ol>
<li>Field getField(String name): 返回Class对应类的、指定名称的public成员变量</li>
<li>Field[] getFields(): 返回Class对应类的、所有的public成员变量</li>
<li>Field getDeclaredField(String name): 返回Class对应类的、指定名称的成员变量，与成员变量的访问权限无关</li>
<li>Field[] getDeclaredFields(): 返回Class对应类的、所有的成员变量，与成员变量的访问权限无关</li>
</ol>
</blockquote>
<p>如下几个方法用于访问Class对应类的Annotation:</p>
<blockquote>
<ol>
<li><a extends="" annotation="">A getAnnotation(Class<a> annotationClass): 获取Class对应类存在的、指定类型的Annotation; 不存在返回null</a></a></li>
<li><a extends="" annotation="">A getDeclaredAnnotation(Class<a> annotationClass): Java8新增方法，获取直接修饰该Class对应类的、指定类型的Annotation;</a></a></li>
<li>Annotation[] getAnnotations(): 返回修饰该Class对应类上所有Annotation</li>
<li>Annotation[] getDeclaredAnnotations(): 返回直接修饰该Class对应类上所有Annotation</li>
<li><a extends="" annotation=""> A[] getDeclaredAnnotationByType(Class<a> annotationClass): 该方法与前面getAnnotation()类似，Java8增加重复注解功能，需要使用该方法直接修饰该类、指定类型的Annotation</a></a></li>
</ol>
</blockquote>
<p>如下方法用于访问Class对应类包含的内部类:</p>
<blockquote>
<ol>
<li>Class&lt;?&gt;[] getDeclaredClasses(): 返回该Class对应类包含的全部内部类</li>
</ol>
</blockquote>
<p>如下方法用于访问Class对应类所在的外部类:</p>
<blockquote>
<ol>
<li>Class&lt;?&gt; getDeclaringClass(): 返回Class对应类所在的外部类</li>
</ol>
</blockquote>
<p>如下方法用于访问Class对应类所实现的接口:</p>
<blockquote>
<ol>
<li>Class&lt;?&gt;[] getInterfaces(): 返回Class对象对应类所实现的全部接口</li>
</ol>
</blockquote>
<p>如下方法用于访问该Class对应类所继承的父类</p>
<blockquote>
<ol>
<li>Class&lt;? super T&gt; getSuperclass(): 返回Class对应类的父类Class对象</li>
</ol>
</blockquote>
<p>如下方法用于获取Class对应类的修饰符、所在包、类名等基本信息:</p>
<blockquote>
<ol>
<li>int getModifiers(): 返回此类后接口的所有修饰符</li>
<li>Package getPackage(): 获取此类的包</li>
<li>String getName(): 返回Class对象所表示类的名称</li>
<li>String getSimpleName(): 返回Class对象所表示类的简称</li>
</ol>
</blockquote>
<p>除此之外Class对象还可调用如下几个判断方法来判断是否为接口、枚举、注解类型等:</p>
<blockquote>
<ol>
<li>boolean isAnnotation(): 返回此Class对象是否表示一个注解类型</li>
<li>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass): 判断此Class对象是否使用了Annotation修饰</li>
<li>boolean isAnonymousClass(): Class对象是否是一个匿名类</li>
<li>boolean isArray(): Class对象是否表示一个数组类</li>
<li>boolean isEnum(): Class对象是否表示一个枚举</li>
<li>boolean isInterface(): Class对象是否表示一个接口</li>
<li>boolean isInstance(Object obj): 判断obj是否是此Class对象的实例，该方法完全可代替instanceof操作符</li>
</ol>
</blockquote>
<h3 id="Java8新增的方法参数反射"><a href="#Java8新增的方法参数反射" class="headerlink" title="Java8新增的方法参数反射"></a>Java8新增的方法参数反射</h3><p>Java8在java.lang.reflect包下新增Executable抽象基类，该类派生Constructor、Method两个子类。<br>Executable提供如下方法获取方法或参数的形参个数及形参名:</p>
<blockquote>
<ol>
<li>int getParameterCount(): 获取该构造器或方法的形参个数</li>
<li>Parameter[] getParameters(): 获取该构造器或方法的所有形参</li>
</ol>
</blockquote>
<p>parameter是Java8新增的API,提供大量方法获取声明该参数的泛型信息，还提供如下方法获取参数信息:</p>
<blockquote>
<ol>
<li>getModifiers(): 获取修饰该形参的修饰符</li>
<li>String getName(): 获取形参名</li>
<li>Type getParameterizedType(): 获取带泛型的形参类型</li>
<li>Class&lt;?&gt; getType(): 获取形参类型</li>
<li>boolean isNamePresent(): 该方法返回该类的class文件中是否包含了方法的形参名信息</li>
<li>boolean isVarArgs(): 该方法用于判断该参数是否为个数可变的形参；<h3 id="动态创建Java对象"><a href="#动态创建Java对象" class="headerlink" title="动态创建Java对象"></a>动态创建Java对象</h3>通过反射生成对应有如下两种方式:</li>
<li>使用Class对象的newInstance()方法创建实例，这种方式要求对应类有默认构造器，执行newInstance()利用默认构造器创建实例</li>
<li>先使用Class对象获取指定Constructor对象，在调用Constructor对象的newInstance()方法创建实例。这种方式可以选择指定构造器创建实例</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种方式</span></div><div class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"java.util.Date"</span>);</div><div class="line">Object obj = clazz.newInstance();</div><div class="line"></div><div class="line"><span class="comment">//第二种方式</span></div><div class="line">Class&lt;?&gt; jframeClazz = Class.forName(<span class="string">"javax.swing.JFrame"</span>);</div><div class="line">Constructor ctor = jframeClazz.getConstructor(String.class);</div><div class="line">Object obj = ctor.newInstance(<span class="string">"测试窗口"</span>);</div></pre></td></tr></table></figure>
<h3 id="动态调用方法"><a href="#动态调用方法" class="headerlink" title="动态调用方法"></a>动态调用方法</h3><p>通过Class对象的getMethod()方法获得Method对象。Method对象包含一个invoke()方法，该方法签名如下:</p>
<blockquote>
<ol>
<li>Object invoke(Object obj, Object… args): 该方法的obj是执行该方法的主调，args是执行该方法传入方法的实参</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获得StringBuffer的Class对象</span></div><div class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"java.lang.StringBuffer"</span>);</div><div class="line"><span class="comment">//获得StringBuffer带有String的构造器</span></div><div class="line">Constructor cotr = clazz.getConstructor(String.class);</div><div class="line"><span class="comment">//创建StringBuffer对象</span></div><div class="line">Object obj = cotr.newInstance(<span class="string">"abcdefg"</span>);</div><div class="line"><span class="comment">//获得StringBuffer的append()方法</span></div><div class="line">Method method = clazz.getMethod(<span class="string">"append"</span>, String.class);</div><div class="line"><span class="comment">//调用StringBuffer的append()方法</span></div><div class="line">method.invoke(obj, <span class="string">"1234"</span>);</div><div class="line">System.out.println(obj.toString());</div></pre></td></tr></table></figure>
<h3 id="访问并修改Java对象的属性值"><a href="#访问并修改Java对象的属性值" class="headerlink" title="访问并修改Java对象的属性值"></a>访问并修改Java对象的属性值</h3><p>通过Class对象提供的获取Field方法获取成员变量。Field提供如下两组方法读取或设置成员变量。</p>
<blockquote>
<ol>
<li>getXxx(Object obj): 获取obj对象的成员变量的值。Xxx对应8中基本类型，如果是引用类型，则取消Xxx</li>
<li>setXxx(Object obj, Xxx val): 设置obj对象的成员变量的val值。Xxx对应8中基本类型，如果是引用类型，则取消Xxx</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Person[name:"</span> + name + <span class="string">", age:"</span> + age + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person p = <span class="keyword">new</span> Person();</div><div class="line">Class&lt;Person&gt; personClazz = Person.class;</div><div class="line">Field nameField = personClazz.getDeclaredField(<span class="string">"name"</span>);</div><div class="line">nameField.setAccessible(<span class="keyword">true</span>);</div><div class="line">nameField.set(p, <span class="string">"张三"</span>);</div><div class="line">Field ageField = personClazz.getDeclaredField(<span class="string">"age"</span>);</div><div class="line">ageField.setAccessible(<span class="keyword">true</span>);</div><div class="line">ageField.setInt(p, <span class="number">18</span>);</div><div class="line">System.out.println(p);</div></pre></td></tr></table></figure>
<h3 id="使用反射操作数组"><a href="#使用反射操作数组" class="headerlink" title="使用反射操作数组"></a>使用反射操作数组</h3><p>java.lang.reflect包下还提供了Array类，Array对象代表数组。程序通过使用Array动态创建数组，操作数组元素。Array提供如下几类方法：</p>
<blockquote>
<ol>
<li>static Object newInstance(Class&lt;?&gt; componentType, int… length): 创建一个具有指定元素类型、指定维度的数组</li>
<li>static xxx getXxx(Object array, int index): 返回array数组中的第index个元素。Xxx对应8中基本类型，如果是引用类型，则取消Xxx</li>
<li>static xxx setXxx(Object array, int index, xxx val): 将array数组中第index个元素设置值为val。Xxx对应8中基本类型，如果是引用类型，则取消Xxx</li>
</ol>
</blockquote>
<h3 id="使用Proxy和InvocationHandler创建动态代理"><a href="#使用Proxy和InvocationHandler创建动态代理" class="headerlink" title="使用Proxy和InvocationHandler创建动态代理"></a>使用Proxy和InvocationHandler创建动态代理</h3><p>Proxy提供了用于创建动态代理类和代理对象的静态方法，它也是所有动态代理类的父类。如果在程序中为一个或多个接口动态生成实现类，可以使用Proxy来创建动态代理类；如果需要为一个或多个接口动态创建实例，也可以使用Proxy创建动态代理实例；<br>Proxy提供了如下两个方法创建动态代理类和动态代理实例：</p>
<blockquote>
<ol>
<li>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces): 创建一个动态代理类所对应的Class对象，该代理类将实现interfaces所指定的多个接口。</li>
<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, Invocationhandler h): 直接创建一个动态代理对象，该代理对象实现类实现了interfaces指定的接口，执行代理对象的每个方法时都会被替换成InvocationHandler对象的invoke方法；</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvokationHandler();</div><div class="line">Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), Person.class);</div><div class="line">Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class);</div><div class="line">Person p = (Person) constructor.newInstance(handler);</div><div class="line">p.walk();</div><div class="line">p.sayHello(<span class="string">"孙悟空"</span>);</div><div class="line"></div><div class="line"><span class="comment">//上面代码可以替换成如下:</span></div><div class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvokationHandler();</div><div class="line">Person p = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Person</div><div class="line">                .class&#125;, handler);</div><div class="line">p.walk();</div><div class="line">p.sayHello(<span class="string">"孙悟空"</span>);</div><div class="line"></div><div class="line"><span class="comment">//完整代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvokationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"---正在执行的方法:"</span> + method);</div><div class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"下面是执行该方法是传入的实参:"</span>);</div><div class="line">            <span class="keyword">for</span> (Object val : args) &#123;</div><div class="line">                System.out.println(val);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            System.out.println(<span class="string">"调用方法没有实参"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        InvocationHandler handler = <span class="keyword">new</span> MyInvokationHandler();</div><div class="line">        Person p = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Person</div><div class="line">                .class&#125;, handler);</div><div class="line">        p.walk();</div><div class="line">        p.sayHello(<span class="string">"孙悟空"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<!--### Class类的泛型-->
<!--### 通过反射获取泛型类型-->
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础(九)]]></title>
      <url>/2017/06/12/Java%E5%9F%BA%E7%A1%80-%E4%B9%9D/</url>
      <content type="html"><![CDATA[<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>通过Java网络通信的支持，Java程序可以方便的访问互联网上的HTTP服务、FTP服务等，并可以直接获取互联网的远程资源，还可以像远程资源发送GET、POST请求。</p>
<h3 id="使用InetAddress包装IP地址"><a href="#使用InetAddress包装IP地址" class="headerlink" title="使用InetAddress包装IP地址"></a>使用InetAddress包装IP地址</h3><p>Java提供了InetAddress类代表IP地址，InetAddress有两个子类:Inet4Address、Inet6Address分别代表IPv4和IPv6。<br>InetAddress没有提供构造器，提供了两个静态方法获取InetAddress实例:</p>
<blockquote>
<ol>
<li>getByName(String host): 根据主机获取对应的InetAddress对象;</li>
<li>getByAddress(byte[] addr): 根据原始IP地址获取对应的InetAddress对象;</li>
</ol>
</blockquote>
<p>InetAddress提供如下三个方法获取InetAddress实例对应的IP地址和主机名:</p>
<blockquote>
<ol>
<li>String getCanonicalHostName(): 获取此IP地址的全限定域名;</li>
<li>String getHostAddress(): 返回该InetAddress实例对应的IP对应的IP字符串;</li>
<li>String getHostName(): 获取IP地址的主机名;</li>
</ol>
</blockquote>
<p>InetAddress还提供getLocalHost()方法获取本机IP地址对应的InetAddress实例;还提供一个用于测试是否可以到达该地址方法:isReachable();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="comment">//根据主机名获取对应的InetAddress实例</span></div><div class="line">        InetAddress ip = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</div><div class="line">        <span class="comment">//判断是否能到达</span></div><div class="line">        System.out.println(<span class="string">"百度是否可达:"</span> + ip.isReachable(<span class="number">2000</span>));</div><div class="line">        <span class="comment">//获取改InetAddress实例的ip</span></div><div class="line">        System.out.println(<span class="string">"百度的IP:"</span> + ip.getHostAddress());</div><div class="line">        <span class="comment">//根据原始IP地址获取对应的InetAddress实例</span></div><div class="line">        InetAddress local = InetAddress.getByAddress(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;);</div><div class="line">        System.out.println(<span class="string">"本机是否可达: "</span> + local.isReachable(<span class="number">2000</span>));</div><div class="line">        <span class="comment">//获取实例对应的全限定域名</span></div><div class="line">        System.out.println(local.getCanonicalHostName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用URLEncoder和URLDecoder工具类"><a href="#使用URLEncoder和URLDecoder工具类" class="headerlink" title="使用URLEncoder和URLDecoder工具类"></a>使用URLEncoder和URLDecoder工具类</h3><p>URLEncoder类包含一个decode(String s, String enc)静态方法，用于将application/x-www-from-urlencoded MIME字符串转换成普通字符串；URLDecoder类包含一个encode(String s, String enc)静态方法，用于将普通字符串转换成application/x-www-from-urlencoded MIME字符串。通俗来讲就是将浏览器地址栏中中文乱码互相转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDecoderTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String keyWord = URLDecoder.decode(<span class="string">"%e5%93%88%e5%93%88%e5%b0%8f%e9%80%97%e6%af%94"</span>, <span class="string">"utf-8"</span>);</div><div class="line">        System.out.println(keyWord);</div><div class="line">        String urlStr = URLEncoder.encode(<span class="string">"哈哈哈"</span>, <span class="string">"utf-8"</span>);</div><div class="line">        System.out.println(urlStr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用URLConnection访问远程资源"><a href="#使用URLConnection访问远程资源" class="headerlink" title="使用URLConnection访问远程资源"></a>使用URLConnection访问远程资源</h3><p>URL类用于创建URL对象，URL是有协议名、主机、端口和资源组成，即下面格式:</p>
<blockquote>
<p>protocol://host:port/resourceName</p>
</blockquote>
<p>URL可以调用如下方法访问URL对应的资源:</p>
<blockquote>
<ol>
<li>String getFile(): 获取URL资源名</li>
<li>String getHost(): 获取URL主机名</li>
<li>String getPath(): 获取URL路径部分</li>
<li>int getPort(): 获取URL端口号</li>
<li>String getProtocol(): 获取URL协议名称</li>
<li>String getQuery(): 获取URL查询字符串部分</li>
<li>URLConnection openConnection():  返回一个URLConnection对象，它代表URL所引用远程对象的连接</li>
<li>InputStream openStream(): 打开与此URL的连接，并返回一个用于读取该URL资源的InputStream</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownUtil</span> </span>&#123;</div><div class="line">    <span class="comment">//下载资源路径</span></div><div class="line">    <span class="keyword">private</span> String path;</div><div class="line">    <span class="comment">//下载文件保存位置</span></div><div class="line">    <span class="keyword">private</span> String targetFile;</div><div class="line">    <span class="comment">//线程个数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</div><div class="line">    <span class="comment">//下载的线程对象数组</span></div><div class="line">    <span class="keyword">private</span> DownThread[] threads;</div><div class="line">    <span class="comment">//文件大小</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fileSize;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownUtil</span><span class="params">(String path, String targetFile, <span class="keyword">int</span> threadNum)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.path = path;</div><div class="line">        <span class="keyword">this</span>.targetFile = targetFile;</div><div class="line">        <span class="keyword">this</span>.threadNum = threadNum;</div><div class="line">        <span class="comment">//初始化threads数组</span></div><div class="line">        <span class="keyword">this</span>.threads = <span class="keyword">new</span> DownThread[threadNum];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        URL url = <span class="keyword">new</span> URL(path);</div><div class="line">        HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">        conn.setConnectTimeout(<span class="number">5</span> * <span class="number">1000</span>);</div><div class="line">        conn.setRequestMethod(<span class="string">"GET"</span>);</div><div class="line">        conn.setRequestProperty(<span class="string">"Accept"</span>, <span class="string">"image/gif, image/jpeg, image/pjpeg, image/pjpeg,"</span> +</div><div class="line">                <span class="string">"application/x-shockwave-flash, application/xmal+xml,"</span> +</div><div class="line">                <span class="string">"application/vnd.ms-xpsdocument, application/x-ms-xbap,"</span> +</div><div class="line">                <span class="string">"application/x-ms-application, application/vnd.ms-excel,"</span> +</div><div class="line">                <span class="string">"application/vnd.ms-powerpoint, application/msword, */*"</span>);</div><div class="line">        conn.setRequestProperty(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN"</span>);</div><div class="line">        conn.setRequestProperty(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</div><div class="line">        conn.setRequestProperty(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</div><div class="line">        <span class="comment">//得到文件大小</span></div><div class="line">        fileSize = conn.getContentLength();</div><div class="line">        conn.disconnect();</div><div class="line">        <span class="keyword">int</span> currentPartSize = fileSize / threadNum + <span class="number">1</span>;</div><div class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(targetFile, <span class="string">"rw"</span>);</div><div class="line">        <span class="comment">//设置本地文件大小</span></div><div class="line">        file.setLength(fileSize);</div><div class="line">        <span class="comment">//关闭文件</span></div><div class="line">        file.close();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</div><div class="line">            <span class="comment">//计算每个线程下载的位置</span></div><div class="line">            <span class="keyword">int</span> startPos = i * currentPartSize;</div><div class="line">            RandomAccessFile currentPart = <span class="keyword">new</span> RandomAccessFile(targetFile, <span class="string">"rw"</span>);</div><div class="line">            <span class="comment">//定位该线程现在的位置</span></div><div class="line">            currentPart.seek(startPos);</div><div class="line">            <span class="comment">//创建下载线程</span></div><div class="line">            threads[i] = <span class="keyword">new</span> DownThread(startPos, currentPartSize, currentPart);</div><div class="line">            threads[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//获取下载的完成百分比</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCompleteRate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sumSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</div><div class="line">            sumSize += threads[i].length;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sumSize * <span class="number">1.0</span> / fileSize;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="comment">//当前线程的下载位置</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> startPos;</div><div class="line">        <span class="comment">//当前线程负责下载的文件大小</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> currentPartSzie;</div><div class="line">        <span class="comment">//当前线程需要下载的文件快</span></div><div class="line">        <span class="keyword">private</span> RandomAccessFile currentPart;</div><div class="line">        <span class="comment">//定义线程已下载的字节数</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> length;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DownThread</span><span class="params">(<span class="keyword">int</span> startPos, <span class="keyword">int</span> currentPartSzie, RandomAccessFile currentPart)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.startPos = startPos;</div><div class="line">            <span class="keyword">this</span>.currentPart = currentPart;</div><div class="line">            <span class="keyword">this</span>.currentPartSzie = currentPartSzie;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                URL url = <span class="keyword">new</span> URL(path);</div><div class="line">                HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">                conn.setConnectTimeout(<span class="number">5</span> * <span class="number">1000</span>);</div><div class="line">                conn.setRequestProperty(<span class="string">"Accept"</span>, <span class="string">"image/gif, image/jpeg, image/pjpeg, image/pjpeg,"</span> +</div><div class="line">                        <span class="string">"application/x-shockwave-flash, application/xmal+xml,"</span> +</div><div class="line">                        <span class="string">"application/vnd.ms-xpsdocument, application/x-ms-xbap,"</span> +</div><div class="line">                        <span class="string">"application/x-ms-application, application/vnd.ms-excel,"</span> +</div><div class="line">                        <span class="string">"application/vnd.ms-powerpoint, application/msword, */*"</span>);</div><div class="line">                conn.setRequestProperty(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN"</span>);</div><div class="line">                conn.setRequestProperty(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</div><div class="line">                InputStream inStream = url.openStream();</div><div class="line">                <span class="comment">//跳过startPos个字节,表明该线程只下载自己负责的那部分</span></div><div class="line">                inStream.skip(<span class="keyword">this</span>.startPos);</div><div class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                <span class="keyword">int</span> hasRead = <span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (length &lt; currentPartSzie &amp;&amp; (hasRead = inStream.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">                    currentPart.write(buffer, <span class="number">0</span>, hasRead);</div><div class="line">                    length += hasRead;</div><div class="line">                &#125;</div><div class="line">                currentPart.close();</div><div class="line">                inStream.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] age)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String path = <span class="string">"https://timgsa.baidu"</span> +</div><div class="line">                <span class="string">".com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1497329776318&amp;di=a95d10efa28b7010991b7de6d892c43a&amp;imgtype=0&amp;src=http%3A%2F%2Fandroid-wallpapers.25pp.com%2Ffs01%2F2014%2F09%2F30%2F0_3675c5ca51a2f5fec8f756217ea66dd6_900x675.jpg"</span>;</div><div class="line">        DownUtil downUtil = <span class="keyword">new</span> DownUtil(path, <span class="string">"ios-bhlin.jpg"</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line">        downUtil.download();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</div><div class="line">            <span class="keyword">while</span> (downUtil.getCompleteRate() &lt; <span class="number">1</span>) &#123;</div><div class="line">                System.out.println(<span class="string">"已完成: "</span> + downUtil.getCompleteRate());</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="TCP协议基础"><a href="#TCP协议基础" class="headerlink" title="TCP协议基础"></a>TCP协议基础</h3><p>TCP协议被称作是一种端对端的协议。当一台计算机需要与另一台计算机连接是，TCP协议会让它们建立连接：用于发送和接受数据的虚拟链路。在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接 时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的；</p>
<h3 id="使用ServerSocket和Socket"><a href="#使用ServerSocket和Socket" class="headerlink" title="使用ServerSocket和Socket"></a>使用ServerSocket和Socket</h3><p>Java中能接受其他通信实体请求的类是ServerSocket,ServerSocket对象用于监听来自客户端Socket的连接，如果没有连接，他将一直处于等待状态。ServerSocket包含一个监听来自客户端连接请求的方法:</p>
<blockquote>
<ol>
<li>Socket accept(): 如果接收到客户端的Socket连接请求，该方法返回一个与客户端Socket对应的Socket;否则该方法会一直处于阻塞线程的状态</li>
<li>ServerSocket(int port): 用指定端口port创建ServerSocket，该端口值0~65535</li>
<li>ServerSocket(int port, int backlog): 增加一个用来改变连接队列长度的参数backlog</li>
<li>ServerSocket(int port, int backlog, InetAddress localAddr): 在机器存在多个IP的情况下，语序通过localAddr参数指定将ServerSocket绑定到指定的IP地址</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ServerSocket ss= <span class="keyword">new</span> ServerSocket(<span class="number">30000</span>);</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">    Socket s = ss.accept();</div><div class="line">    <span class="comment">//下面就可以使用Socket进行通信了</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端通常使用Socket的构造器指定服务器:</p>
<blockquote>
<ol>
<li>Socket(InetAddress/String remoteAddress, int port): 连接到指定远程主机、端口,该构造器没有指定本地地址和本地端口，默认使用本地主机的IP和系统动态分配的端口</li>
<li>Socket(InetAddress/String remoteAddress, int port, InetAddress localAddr, int localPort): 连接到指定远程主机、端口，并指定本地ip和本地端口</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">30000</span>);</div><div class="line"><span class="comment">//上面代码就会连接到指定的服务器，让服务端的accept()方法向下执行</span></div><div class="line"></div><div class="line"><span class="comment">//下面就可以使用Socket进行通信了</span></div></pre></td></tr></table></figure>
<p>Socket提供了两个方法获取输入流和输出流</p>
<blockquote>
<ol>
<li>InputStream getInputStream(): 返回该Socket对象对应的输入流，让程序通过输入流从Socket中取数据</li>
<li>OutputStream getOutputStream(): 返回该Socket对象对应的输出流，让程序通过输出流从Socket中输出数据</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">30000</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Socket s = ss.accept();</div><div class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(s.getOutputStream());</div><div class="line">            ps.println(<span class="string">"你好,你收到了服务器的推送消息"</span>);</div><div class="line">            ps.close();</div><div class="line">            s.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">30000</span>);</div><div class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</div><div class="line">        String line = br.readLine();</div><div class="line">        System.out.println(<span class="string">"来自服务器的数据: "</span> + line);</div><div class="line">        br.close();</div><div class="line">        s.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用NIO实现非阻塞式网络通信"><a href="#使用NIO实现非阻塞式网络通信" class="headerlink" title="使用NIO实现非阻塞式网络通信"></a>使用NIO实现非阻塞式网络通信</h3><p>Java的NIO为非阻塞式Socket通信提供了如下几个特殊类:</p>
<blockquote>
<ol>
<li>Selector: 它是SelectableChannel对象的多路复用器，所有采用非阻塞方式进行通信的Cannel都应该注册Selector对象。通过通过调用此类的<font color="red">open()</font>静态方法创建Selector实例，该方法使用系统默认的Selector来返回新的Selector</li>
</ol>
</blockquote>
<p>Selector可以同时监控多个SelectableChannel的IO状况，是非阻塞IO的核心。一个Selector实例有三个SelectionKey集合:</p>
<blockquote>
<ol>
<li>所有的SelectionKey的集合: 注册在该Selector上的Channel，调用keys()方法返回</li>
<li>被选择的SelectionKey的集合: 所有可以通过select()方法获取的、需要进行IO处理的Channel，调用selectedKeys()返回</li>
<li>被取消的SelectionKey集合: 代表所有被取消注册关系的Channel,在下次执行select()方法时，这个Channel对应的SelectionKey会被彻底删除，程序无须直接方法该集合</li>
</ol>
</blockquote>
<p>除此之外Selector还提供一系列和select()相关的方法:</p>
<blockquote>
<ol>
<li>int select(): 监控所有注册的Channel，当它们中间需要进行IO处理时，该方法返回，并将对应的SelectionKey加入被选择的SelectionKey集合中，返回这些Channel的数量；</li>
<li>int select(long timeout): 可以设置超时时间的select()操作；</li>
<li>int selectNow(): 执行一个立即返回select()操作，相对于无参的select()方法而言，该方法不会阻塞线程</li>
<li>Selector wakeup(): 使一个还未返回的select()方法立刻返回</li>
<li>SelectableChannel: 可以支持非阻塞IO操作的Channel对象，它可被注册到Selector上，这种注册关系有SelectionKey实例表示。Selector对象提供了一个select()方法，该方法允许应用程序同事监控多个IO Channel</li>
</ol>
</blockquote>
<p>可调用SelectableChannel的register()方法将其注册到指定的Selector上，当该Selector上的SelectableChannel需要处理IOc操作，可以调用Selector实例的select()方法获取他们数量，通过selectedKeys()获取需要处理IO的SelectableChannel集<br>SelectableChannel支持阻塞和非阻塞两种模式：</p>
<blockquote>
<ol>
<li>SelectableChannel configureBlocking(boolean block): 是否采用阻塞模式</li>
<li>boolean isBlocking(): 返回该Channel是否是阻塞模式</li>
</ol>
</blockquote>
<p>不同的SelectableChanne支持的操作不一样，例如ServerSocketChannel代表一个ServerSocket，它只支持OP_ACCEPT操作。<br>除此之外，SelectableChannel还提供了如下几个方法来获取它的注册状态:</p>
<blockquote>
<ol>
<li>boolean isRegistered(): 返回该Channel是否已注册在一个或多个Selector上</li>
<li>SelectionKey keyFor(Selector sel): 返回Channel和sel之间注册关系</li>
<li>SelectionKey: 该对象代表SelectableChannel和Selector之间的注册关系</li>
<li>ServerSocketChannel: 支持非阻塞操作，只支持OP_ACCEOT操作,相当于java.net.serverSocket类<br>5、SocketChannel: 支持非阻塞操作，支持OP_CONNECT、OP_READ、OP_WRITE操作，相当于java.net.Socket类</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NServer</span> </span>&#123;</div><div class="line">    <span class="comment">//用于检测所有Channel状态的Selector</span></div><div class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">30000</span>;</div><div class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        selector = Selector.open();</div><div class="line">        <span class="comment">//用open方法打开一个未绑定的serverSocketChannel实例</span></div><div class="line">        ServerSocketChannel server = ServerSocketChannel.open();</div><div class="line">        InetSocketAddress isa = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, PORT);</div><div class="line">        <span class="comment">//将改ServerSocketChannel绑定指定IP地址</span></div><div class="line">        server.bind(isa);</div><div class="line">        <span class="comment">//设置ServerSocket以非阻塞方式工作</span></div><div class="line">        server.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">//将server注册到指定的Selector对象</span></div><div class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//依次处理selector上每个已选择的SelectionKey</span></div><div class="line">            <span class="keyword">for</span> (SelectionKey sk : selector.selectedKeys()) &#123;</div><div class="line">                <span class="comment">//从已选择的key中删除正在处理的sk</span></div><div class="line">                selector.selectedKeys().remove(sk);</div><div class="line">                <span class="comment">//sk对应的Channel包含客户端的连接请求</span></div><div class="line">                <span class="keyword">if</span> (sk.isAcceptable()) &#123;</div><div class="line">                    <span class="comment">//调用accept方法接受连接,产生服务端的SocketChannel</span></div><div class="line">                    SocketChannel sc = server.accept();</div><div class="line">                    <span class="comment">//设置非阻塞模式</span></div><div class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                    <span class="comment">//将sc注册到selector上</span></div><div class="line">                    sc.register(selector, SelectionKey.OP_READ);</div><div class="line">                    <span class="comment">//将sk对应的Channel设置成准备接受其他请求</span></div><div class="line">                    sk.interestOps(SelectionKey.OP_ACCEPT);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//sk对应的Channel有数据需要读取</span></div><div class="line">                <span class="keyword">if</span> (sk.isReadable()) &#123;</div><div class="line">                    <span class="comment">//获取SelectionKey对应的Channel,该Channel中有可读的数据</span></div><div class="line">                    SocketChannel sc = (SocketChannel) sk.channel();</div><div class="line">                    <span class="comment">//定义准备执行读取数据的ByteBuffer</span></div><div class="line">                    ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">                    String content = <span class="string">""</span>;</div><div class="line">                    <span class="comment">//开始读取数据</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">while</span> (sc.read(buff) &gt; <span class="number">0</span>) &#123;</div><div class="line">                            buff.flip();</div><div class="line">                            content += charset.decode(buff);</div><div class="line">                        &#125;</div><div class="line">                        System.out.println(<span class="string">"读取的数据: "</span> + content);</div><div class="line">                        <span class="comment">//将sk对应的Channel设置成准备下一次读取</span></div><div class="line">                        sk.interestOps(SelectionKey.OP_READ);</div><div class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        <span class="comment">//如果捕获到了sk对应的Channel出现的异常,即表明该Channel对应的Client出现了问题,所以从Selector中取消sk的注册</span></div><div class="line">                        sk.cancel();</div><div class="line">                        <span class="keyword">if</span> (sk.channel() != <span class="keyword">null</span>) &#123;</div><div class="line">                            sk.channel().close();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (content.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</div><div class="line">                            Channel targetChannel = key.channel();</div><div class="line">                            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span>  SocketChannel) &#123;</div><div class="line">                                SocketChannel dest = (SocketChannel) targetChannel;</div><div class="line">                                dest.write(charset.encode(content));</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"--------server while下面--------------"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> NServer().init();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NClient</span> </span>&#123;</div><div class="line">    <span class="comment">//用于检测所有Channel状态的Selector</span></div><div class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">30000</span>;</div><div class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">    <span class="keyword">private</span> SocketChannel sc = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        selector = Selector.open();</div><div class="line">        InetSocketAddress isa = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, PORT);</div><div class="line">        <span class="comment">//调用open静态方法创建连接到指定主机的SocketChannel</span></div><div class="line">        sc = SocketChannel.open(isa);</div><div class="line">        <span class="comment">//设置sc以非阻塞方式工作</span></div><div class="line">        sc.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">//将SocketChannel对象注册到指定的Selector</span></div><div class="line">        sc.register(selector, SelectionKey.OP_READ);</div><div class="line">        <span class="comment">//启动读取服务端数据的线程</span></div><div class="line">        <span class="keyword">new</span> ClientThread().start();</div><div class="line">        <span class="comment">//获取键盘输入流</span></div><div class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">while</span> (scan.hasNextLine()) &#123;</div><div class="line">            String line = scan.nextLine();</div><div class="line">            sc.write(charset.encode(line));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">for</span> (SelectionKey sk : selector.selectedKeys()) &#123;</div><div class="line">                        selector.selectedKeys().remove(sk);</div><div class="line">                        <span class="keyword">if</span> (sk.isReadable()) &#123;</div><div class="line">                            SocketChannel sc = (SocketChannel) sk.channel();</div><div class="line">                            ByteBuffer buff = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">                            String content = <span class="string">""</span>;</div><div class="line">                            <span class="keyword">while</span> (sc.read(buff) &gt; <span class="number">0</span>) &#123;</div><div class="line">                                sc.read(buff);</div><div class="line">                                buff.flip();</div><div class="line">                                content += charset.decode(buff);</div><div class="line">                            &#125;</div><div class="line">                            System.out.println(<span class="string">"聊天信息:"</span> + content);</div><div class="line">                            sk.interestOps(SelectionKey.OP_READ);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> NClient().init();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<!--### 使用AIO实现异步网络通信-->
<h3 id="UDP协议基础"><a href="#UDP协议基础" class="headerlink" title="UDP协议基础"></a>UDP协议基础</h3><p>UDP协议是一种不可靠的网络协议，它在通信两端各自建立一个Socket，这两个Socket只是发送、接受数据报的对象。Java提供了DatagramSocket对象作为基于UDP协议的Socket,使用DatagramPacket代表DatagramSocket发送、接受数据报；</p>
<h3 id="使用DatagramSocket发送-接受数据报-DatagramPacket"><a href="#使用DatagramSocket发送-接受数据报-DatagramPacket" class="headerlink" title="使用DatagramSocket发送/接受数据报(DatagramPacket)"></a>使用DatagramSocket发送/接受数据报(DatagramPacket)</h3><p>Java使用DatagramSocket代表UDP协议的Socket,DatagramSocket不维护状态不能产生IO流，唯一作用就是接受和发送数据报，Java使用DatagramPacket来代表数据报，DatagramSocket接受和发送的数据都是通过DatagramPacket对象完成的；<br>DatagramSocket的构造器:</p>
<blockquote>
<ol>
<li>DatagramSocket(): 创建一个DatagramSocket实例，并将该对象绑定本机默认ip，本机随机端口</li>
<li>DatagramSocket(int port): 创建一个DatagramSocket实例，绑定本机默认ip，指定端口</li>
<li>DatagramSocket(int port, InetAddress laddr): 创建一个DatagramSocket实例，绑定指定ip、端口</li>
</ol>
</blockquote>
<p>通过如下方法来接收和发送数据:</p>
<blockquote>
<ol>
<li>receive(DatagramPacket p): 从该DatagramSocket中接收数据报</li>
<li>send(DatagramPacket p): 以该DatagramSocket对象向外发送数据报</li>
</ol>
</blockquote>
<p>DatagramPacket的构造器:</p>
<blockquote>
<ol>
<li>DatagramPacket(byte[] buf, int length): 以一个空数组来创建DatagramPacket对象，该对象的作用是接收DatagramSocket中的数据；</li>
<li>DatagramPacket(byte[] buf, int length, InetAddress addr, int port): 以一个包含数据的数组来创建DatagramPacket对象，创建该DatagramPacket对象指定IP和端口——这就决定了该数据报的目的地</li>
<li>DatagramPacket(byte[] buf, int offset, int length): 以一个空数组来创建DatagramPacket对象，并指定接收到的数据放入buf数组中时从offset开始，最多放length个字节</li>
<li>DatagramPacket(byte[] buf, int offset, int length, InetAddress addr, int port): 创建一个用于发送的DataPacket对象，指定发送buf数组中从offset开始，总共length个字节;</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//接受数据用上面的1、3创建接受对象</span></div><div class="line"><span class="comment">//创建一个接受数据的DatagramPacket对象</span></div><div class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, <span class="number">256</span>);</div><div class="line"><span class="comment">//接受数据报</span></div><div class="line">socket.receive(packet);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//发送数据报用上面2、4创建发送对象</span></div><div class="line"><span class="comment">//创建一个发送数据报的DatagramPacket对象</span></div><div class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, length,address, port);</div><div class="line"><span class="comment">//发送数据报</span></div><div class="line">socket.send(packet);</div></pre></td></tr></table></figure>
<!--### 使用MulticastSocket实现多点广播-->
<h3 id="通过Proxy使用代理服务器"><a href="#通过Proxy使用代理服务器" class="headerlink" title="通过Proxy使用代理服务器"></a>通过Proxy使用代理服务器</h3><p>Java5开始提供Proxy和ProxySelector两个类，Proxy代表一个代理服务器，可以在URLConnection连接时指定Proxy，创建Socket连接时也可以指定Proxy;<br>Proxy有一个构造器:Proxy(Proxy.Type type, SocketAddress sa),用于创建Proxy对象，sa参数指定代理服务器的地址，type代表代理服务器的类型，类型有如下三种:</p>
<blockquote>
<ol>
<li>Proxy.Type.DIRECT: 表示直接连接，不使用代理</li>
<li>Proxy.Type.HTTP: 表示支持高级代理协议，如HTTP或FTP</li>
<li>Proxy.TYpe.SOCKS: 表示SOCKS(V4或V5)代理</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> String PROXY_ADDR = <span class="string">"129.82.12.188"</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> PROXY_PORT = <span class="number">3124</span>;</div><div class="line"></div><div class="line">    String urlStr = <span class="string">"http://www.crazyit.org"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        URL url = <span class="keyword">new</span> URL(urlStr);</div><div class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(Proxy.Type.HTTP, <span class="keyword">new</span> InetSocketAddress(PROXY_ADDR, PROXY_PORT));</div><div class="line"></div><div class="line">        URLConnection conn = url.openConnection(proxy);</div><div class="line"></div><div class="line">        conn.setConnectTimeout(<span class="number">3000</span>);</div><div class="line"></div><div class="line">        Scanner scan = <span class="keyword">new</span> Scanner(conn.getInputStream());</div><div class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"index.html"</span>);</div><div class="line">        <span class="keyword">while</span> (scan.hasNextLine()) &#123;</div><div class="line">            String line = scan.nextLine();</div><div class="line">            System.out.println(line);</div><div class="line">            ps.println(line);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> ProxyTest().init();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通过ProxySelector使用代理服务器"><a href="#通过ProxySelector使用代理服务器" class="headerlink" title="通过ProxySelector使用代理服务器"></a>通过ProxySelector使用代理服务器</h3><p>Java5开始提供Proxy和ProxySelector两个类，ProxySelector代表一个代理选择器，他提供了对代理服务器更加灵活地控制，可以分别对HTTP、HTTPS、FTP、SOCKS等进行分别设置，还可以设置不需要通过代理服务器的主机和地址;<br>使用Proxy对象每次都要显示指定代理服务器，比较麻烦。如果希望每次打开总是具有默认的代理服务器，则要借助于ProxySelector来实现。<br>ProxySelector代表一个代理选择器，它是一个抽象类，程序无法创建他的实例，可以考虑继承ProxySelector来实现自己的代理选择器。创建一个继承ProxySelector的类，并让该类实现如下两个抽象方法:</p>
<blockquote>
<ol>
<li>List<proxy> select(URI uri): 根据业务需要返回搭理服务器列表，如果该方法返回的集合中只包含一个Proxy，该Proxy将会作为默认的代理服务器；</proxy></li>
<li>connectFailed(URI uri, SocketAddress sa, IOException ioe): 连接代理服务器失败时回调该方法;</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySelectorTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> String PROXY_ADDR = <span class="string">"139.82.12.188"</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> PROXY_PORT = <span class="number">3124</span>;</div><div class="line">    String urlStr = <span class="string">"http://www.crazyit.org"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ProxySelector.setDefault(<span class="keyword">new</span> ProxySelector() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> List&lt;Proxy&gt; <span class="title">select</span><span class="params">(URI uri)</span> </span>&#123;</div><div class="line">                List&lt;Proxy&gt; result = <span class="keyword">new</span> ArrayList&lt;Proxy&gt;();</div><div class="line">                result.add(<span class="keyword">new</span> Proxy(Proxy.Type.HTTP, <span class="keyword">new</span> InetSocketAddress(PROXY_ADDR, PROXY_PORT)));</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(URI uri, SocketAddress sa, IOException ioe)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"无法连接到指定代理服务器"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);        </div><div class="line">        URL url = <span class="keyword">new</span> URL(urlStr);</div><div class="line">        URLConnection conn = url.openConnection();</div><div class="line">        <span class="comment">//....</span></div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面打开连接没有指定代理服务器，但是实际上还是使用了代理服务器。除此之外，Java为ProxySelector提供了一个实现类，sun.net.spi.DefaultProxySelector(这是一个未公开的API,应尽量避免使用该API)</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础(八)]]></title>
      <url>/2017/06/07/Java%E5%9F%BA%E7%A1%80-%E5%85%AB/</url>
      <content type="html"><![CDATA[<h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h2><p>IO(输入/输出)是比较乏味的事情，因为看不到明显的运行效果，但输入/输出是所有程序都必须使用的部分——输入机制，允许程序去读外部数据(存储设备)、用户输入数据；输出机制,允许程序记录运行状态，将程序数据输出到存储设备中。<br>Java的IO通过java.io包下的类和接口支持，java.io包括输入、输出两种IO流，每种输入、输出流又可分为字节流和字符流。Java7在java.nio及其子包下同一系列全新的API，这些API对原有新IO的升级，因此也被称为NIO2,更高效的进行输入、输出操作。</p>
<h3 id="使用File类访问本地文件系统"><a href="#使用File类访问本地文件系统" class="headerlink" title="使用File类访问本地文件系统"></a>使用File类访问本地文件系统</h3><p>File类是java.io包下进行操作文件和目录。File能新建、删除、重命名和目录，FIle不能访问文件内容。如果要访问文件内容则需要使用输入/输出流。<br>File类可以通过文件路径创建File实例，文件路径可以是绝对路径也可以是相对路径。File类提供了很多方法操作文件和目录，下面列出一些常用方法：</p>
<blockquote>
<ol>
<li>String getName():返回File对象所表示的文件名或路径名</li>
<li>String getPath(): 返回File对象对应的路径名</li>
<li>File getAbsoluteFile(): 返回File对象的绝对路径</li>
<li>String getAbsolutePath():返回File对象所对应的绝对路径</li>
<li>String getParent(): 返回File对象所对应目录的父目录名</li>
<li>boolean renameTo(File newName): 重命名此File对象所对应的文件或目录</li>
</ol>
</blockquote>
<p>文件检测相关的方法</p>
<blockquote>
<ol>
<li>boolean exists(): 判断文件或目录是否存在</li>
<li>boolean canWrite(): 判断文件和目录是否可写</li>
<li>boolean canRead(): 判断文件和目录是否可读</li>
<li>boolean isFile(): 判断是否是文件</li>
<li>boolean isDiretory(): 判断是否是目录</li>
<li>boolean isAbsolute(): 判断是否是绝对路径</li>
</ol>
</blockquote>
<p>获取常规文件信息</p>
<blockquote>
<ol>
<li>long lastModified(): 返回文件的最后修改时间</li>
<li>long length(): 返回文件内容的长度</li>
</ol>
</blockquote>
<p>文件操作相关的方法</p>
<blockquote>
<ol>
<li>boolean createNewFile(): 当文件不存在时创建文件</li>
<li>boolean delete(): 删除文件或路径</li>
<li>static File createTempFile(String prefix, String suffix): 在默认临时文件目录创建一个临时空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名</li>
<li>static File createTempFile(String prefix, String suffix, File directory):在directory目录创建一个临时空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名</li>
<li>void deleteOnExit(): 注册一个删除钩子，当Java虚拟机退出时，删除File对象所对应的文件和目录 </li>
</ol>
</blockquote>
<p>目录操作相关方法</p>
<blockquote>
<ol>
<li>boolean mkdir(): 创建目录</li>
<li>String[] list(): 返回子文件名和路径名</li>
<li>File[] listFiles(): 返回所有子文件和路径</li>
<li>static File[] listRoots(): 返回系统所有的根路径</li>
</ol>
</blockquote>
<h3 id="使用文件过滤器"><a href="#使用文件过滤器" class="headerlink" title="使用文件过滤器"></a>使用文件过滤器</h3><p>File类的list()方法可以接受FilenameFilter参数，该参数可以过滤出只有符合条件的文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"."</span>);</div><div class="line"><span class="comment">//筛选出文件名以.java结尾或者是路径的</span></div><div class="line">String [] nameList = file.list((dir, name) -&gt; name.endsWith(<span class="string">".java"</span>) || <span class="keyword">new</span> File(name).isDirectory());</div><div class="line">System.out.println(nameList);</div></pre></td></tr></table></figure></p>
<h3 id="理解IO流的模型和处理方式"><a href="#理解IO流的模型和处理方式" class="headerlink" title="理解IO流的模型和处理方式"></a>理解IO流的模型和处理方式</h3><p>Java的IO流是实现输入/输出的基础，在Java中把不同的输入/输出源的抽象表述为”流”。流(stream)是从起源(source)到接受(sink)的有序数据。<br>按照不同的分类方式，可以将流分为不同的类型。</p>
<blockquote>
<ol>
<li>输入和输出流: 输入流只能从中读取数据，不能写入数据; 输出流只能写入数据，不能读取数据</li>
<li>字节流和字符流: 字节流操作的数据单元是8位字节，字符流操作的数据单元是16为的字符</li>
<li>节点流和处理流: 从/向一个特定的IO设备读/写数据的流称为节点流也称低级流;处理流则用于对于一个已经存在的流进行连接或者封装，通过封装后的流来实现数据读/写功能。</li>
</ol>
</blockquote>
<p>Java的IO流共涉及40多个类,这些类都是从如下4个抽象基类派生的:</p>
<blockquote>
<ol>
<li>InputStream/Reader: 所有输入流的基类，前者是字节流，后者是字符流</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节流，后者是字符流</li>
</ol>
</blockquote>
<p>InputStream和Reader是所有输入流的抽象基类，它们的方法是所有输入流都可使用的方法:<br>在InputStream里包含如下三个方法：</p>
<blockquote>
<ol>
<li>int read(): 从输入流中读取单个字节，返回读取的字节数据(字节数据可直接转换int类型)</li>
<li>int read(byte[] b):从输入流中最多读取b.length个字节数据，并将其存储在字节数组中，返回实际读取的字节数</li>
<li>int read(byte[] b, int off, int len):从输入流中最多读取len个字节数据，放在字节数组中，并不是从数组起点开始，而是从off位置开始</li>
</ol>
</blockquote>
<p>在Reader里包含如下三个方法：</p>
<blockquote>
<ol>
<li>int read(): 从输入流中读取单个字符</li>
<li>int read(char[] cbuf):从输入流中最多读取cbuf.length个字符数据，并将其放在cbuf字符数组中,返回字符数</li>
<li>int read(char[] b, int off, int len):从输入流中最多读取len个字符数据，放在字符数组中，并不是从数组起点开始，而是从off位置开始，返回字符数<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建字节输入流</span></div><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"FileInputStreamTest.java"</span>);</div><div class="line"><span class="keyword">byte</span>[] bbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">int</span> hasRead = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> ((hasRead = fis.read(bbuf)) &gt; <span class="number">0</span>) &#123;</div><div class="line">    System.out.println(<span class="keyword">new</span> String bbuf, <span class="number">0</span>, hasRead);</div><div class="line">&#125;</div><div class="line">fis.close();</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>OutputStream和Writer是所有输出流的抽象基类，它们的方法是所有输出流都可使用的方法:<br>在OutputStream里包含如下三个方法：</p>
<blockquote>
<ol>
<li>void write(int c): 将指定字节/字符输出到输出流中， 其中c既可以为字符也可以为字节</li>
<li>void write(byte[]/char[] b):将字节数组/字符数据输出到自定输出流中</li>
<li>void write(byte[]/char[] b, int off, int len):将字节数组/字符数据从off位置开始，长度为len输出到指定输出流中</li>
</ol>
</blockquote>
<p>在Writer里包含如下三个方法：</p>
<blockquote>
<ol>
<li>void write(Sring str): 将str字符串里包含的字符输出到指定输出流中</li>
<li>void write(String, int off, int len):将str字符串从off位置开始，len长度输出到指定输出流中</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"FileInputStreamTest.java"</span>);</div><div class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"newFile.txt"</span>);</div><div class="line"><span class="keyword">byte</span>[] bbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</div><div class="line"><span class="keyword">int</span> hasRead = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>((hasRead = fis.read(bbuf)) &gt; <span class="number">0</span>) &#123;</div><div class="line">    fos.write(bbuf, <span class="number">0</span>, hasRead);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fis.close();</div><div class="line">fos.close();</div></pre></td></tr></table></figure>
<p>Java的输入/输出流体系提供了进40个类，这些类看上去没有规律，如果将其按功能进行分类，则不难发现其是非常规律的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">字节输入流</th>
<th style="text-align:left">字节输出流</th>
<th style="text-align:left">字符输入流</th>
<th style="text-align:left">字符输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">抽象基类</td>
<td style="text-align:left">InputStream</td>
<td style="text-align:left">OutputStream</td>
<td style="text-align:left">Read</td>
<td style="text-align:left">Writer</td>
</tr>
<tr>
<td style="text-align:left">访问文件</td>
<td style="text-align:left">FileInputStream</td>
<td style="text-align:left">FileOutputStream</td>
<td style="text-align:left">FileRead</td>
<td style="text-align:left">FileWriter</td>
</tr>
<tr>
<td style="text-align:left">访问数组</td>
<td style="text-align:left">ByteArrayInput<br>Stream</td>
<td style="text-align:left">ByteArrayOutput<br>Stream</td>
<td style="text-align:left">CharArrayRead</td>
<td style="text-align:left">CharArrayWriter</td>
</tr>
<tr>
<td style="text-align:left">访问管道</td>
<td style="text-align:left">PipedInputStream</td>
<td style="text-align:left">PipedOutputStr<br>eam</td>
<td style="text-align:left">PipedRead</td>
<td style="text-align:left">PipedWriter</td>
</tr>
<tr>
<td style="text-align:left">访问字符串</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">StringRead</td>
<td style="text-align:left">StringWriter</td>
</tr>
<tr>
<td style="text-align:left">缓冲流</td>
<td style="text-align:left">BufferedInputStr<br>eam</td>
<td style="text-align:left">BufferedOutputS<br>tream</td>
<td style="text-align:left">BufferedRead</td>
<td style="text-align:left">BufferedWriter</td>
</tr>
<tr>
<td style="text-align:left">转换流</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">InputStreamRead</td>
<td style="text-align:left">OutputWriter</td>
</tr>
<tr>
<td style="text-align:left">对象流</td>
<td style="text-align:left">ObjectInputStream</td>
<td style="text-align:left">ObjectOutputStr<br>eam</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">抽象基类</td>
<td style="text-align:left">FilterInputStream</td>
<td style="text-align:left">FilterOutputStream</td>
<td style="text-align:left">FilterRead</td>
<td style="text-align:left">FilterWriter</td>
</tr>
<tr>
<td style="text-align:left">打印流</td>
<td style="text-align:left"></td>
<td style="text-align:left">PrintStream</td>
<td style="text-align:left"></td>
<td style="text-align:left">PrintWriter</td>
</tr>
<tr>
<td style="text-align:left">推回输入流</td>
<td style="text-align:left">PushbackInputSt<br>ream</td>
<td style="text-align:left"></td>
<td style="text-align:left">PushbackRead</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">特殊流</td>
<td style="text-align:left">DataInputStream</td>
<td style="text-align:left">DataOutputStream</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<h3 id="使用转换流将字节流转换成字符流"><a href="#使用转换流将字节流转换成字符流" class="headerlink" title="使用转换流将字节流转换成字符流"></a>使用转换流将字节流转换成字符流</h3><p>转换流用于将字节流转换成字符流，其中InputStreamRead将字节输入流转换成字符输入流，OutputStreamWriter将字节输出流转换成字符输出流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>(</div><div class="line">    <span class="comment">//将System.in对象转换成Reader对象</span></div><div class="line">    InputStreamRead reader = <span class="keyword">new</span> InputStreamRead(System.in);</div><div class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(reader);</div><div class="line">    )</div><div class="line">&#123;</div><div class="line">    String line = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (line.equals(<span class="string">"exit"</span>)) &#123;</div><div class="line">            System.exit(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"输入内容为："</span> +  line);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<!--### 推回流的功能和用法-->
<!--### 重定向标准输入、输出-->
<!--### 访问其他进程的输入、输出-->
<h3 id="RandomAccessFile的功能和用法"><a href="#RandomAccessFile的功能和用法" class="headerlink" title="RandomAccessFile的功能和用法"></a>RandomAccessFile的功能和用法</h3><p>RandomAccessFile是Java输入/输出流功能最丰富的文件内容访问类。他既可以读取文件内容，也可以向文件输出数据。与普通的输入/输出流不同的是RandomAccessFile支持”随机访问”的方式，程序可以直接跳转到文件任意地方来读写数据。RandomAccessFile可以向已存在的文件后追加内容。<br>RandomAccessFile虽然方法多，但是只能读写文件不能读写其他IO节点。<br>RandomAccessFile对象也包含一个记录指针，用于表示当前读写的位置。新创建一个RandomAccessFile对象，文件记录指针位于文件头，当读写n个字节，文件记录指针向后移动n个字节，该指针可以自由移动。RandomAccessFile包含两个方法操作文件记录指针</p>
<blockquote>
<ol>
<li>long getFilePointer():返回文件记录指针的位置</li>
<li>void seek(lng pos): 将文件记录指针定位到pos位置</li>
</ol>
</blockquote>
<p>RandomAccessFile对象有个model参数，指定访问模式：</p>
<blockquote>
<ol>
<li>“r”: 只读方式打开文件，写入将抛出异常</li>
<li>“rw”: 以读、写方式打开文件，如果不存在，则创建文件</li>
<li>“rws”: 以读、写方法打开文件，相当于”rw”模式，还要求对文件的内容或元数据的每个更新都同步到底层存储设备</li>
<li>“rwd”:以读、写方法打开文件，相当于”rw”模式，还要求对文件的内容的每个更新都同步到底层存储设备</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>(</div><div class="line">    RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"RandomAccessFileTest.java"</span>, <span class="string">"r"</span>)</div><div class="line">    )</div><div class="line">&#123;</div><div class="line">    System.out.println(<span class="string">"记录指针初始位置"</span> + raf.getFilepointer());</div><div class="line">    raf.seek(<span class="number">300</span>);</div><div class="line">    <span class="keyword">byte</span>[] bbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">    <span class="keyword">int</span> hasRead = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> ((hasRead = raf.read(bbuf)) &gt; <span class="number">0</span>) &#123;</div><div class="line">        System.out.println(<span class="keyword">new</span> String(bbuf, <span class="number">0</span>, hasRead));</div><div class="line">    &#125;</div><div class="line">&#125;<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">    ex.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象序列化机制和作用"><a href="#对象序列化机制和作用" class="headerlink" title="对象序列化机制和作用"></a>对象序列化机制和作用</h3><p>序列化机制允许将实现序列化的Java对象准换成字节序列，这些字节序列可以保存在磁盘上，或者通过网络传输，以备以后重新恢复成原来的而对象。序列化机制使得对象脱离程序而独立存在。<br>对象的序列化指将一个Java对象写入IO流中，与此对象的是，对象的反序列话则指从IO流中恢复该Java对象。<br>为了让某个类可序列化，该类必须支持如下两个接口之一：</p>
<blockquote>
<ol>
<li>Serializable : Java很多类已经实现该接口，该接口是一个标记接口</li>
<li>Externalizable</li>
</ol>
</blockquote>
<h3 id="通过实现Serializable接口实现序列化"><a href="#通过实现Serializable接口实现序列化" class="headerlink" title="通过实现Serializable接口实现序列化"></a>通过实现Serializable接口实现序列化</h3><p>如果要序列化对象中包含可饮用类型，那么这个引用类型必须是可序列化得，否则拥有该类型成员变量的类也是不可序列化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//序列化对象</span></div><div class="line"><span class="comment">//创建一个ObjectOutputStream输出流</span></div><div class="line">ObjectOutputStrem oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"object.txt"</span>));</div><div class="line"><span class="comment">//将一个Person对象输出到输出流中</span></div><div class="line">oos.writeObject(person);</div><div class="line"></div><div class="line"><span class="comment">//反序列化对象</span></div><div class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"object.txt"</span>));</div><div class="line">Person p = (Person)ois.readObject();</div></pre></td></tr></table></figure>
<h3 id="实现定制的序列化"><a href="#实现定制的序列化" class="headerlink" title="实现定制的序列化"></a>实现定制的序列化</h3><p>在某些场景下某个类中的某个实例变量不要序列化则需要在修饰符后添加transient修饰;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</div></pre></td></tr></table></figure></p>
<p>使用transient关键字修饰虽然简单、方便，但被transient修饰的变量完全隔离在序列化机制之外，这样导致在发序列化恢复Java对象是无法取得该实例的变量。Java还提供了自定义序列化机制，通过这种序列化机制可让程序控制如何序列化各实例变量。在序列化和反序列化过程中需要特殊处理类应提供如下特殊方法，这些特殊方法用以实现自定义序列化：</p>
<blockquote>
<ol>
<li>private void writeObject(java.io.ObjectOutputStream out) throw IOException; 负责写入特定类的实例状态，一边响应的readObject()方法可以恢复，通过重写该方法，程序员可以完全获得对序列化机制的控制，可以自主决定哪些实例变量需要序列化</li>
<li>private void readObject(java.io.ObjectInputStream in)throws IOException, ClassNotFoundException; 负责从流中读取并回复对象实例变量，通过重写该方法，程序员可以完全获的对反序列话机制的控制，可以自主决定需要反序列化哪些实例变量</li>
<li>private void readObjectNoData()throws ObjectStreamException; 当序列化流不完整时，可以用来正确的初始化反序列化对象</li>
</ol>
</blockquote>
<p>writeObject()方法存储实例变量的顺序应该和readObject()方法中恢复实例变量的顺序一致，否则将不能正确恢复该Java对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"有参数构造器"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//省略name与age的setter和getter方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> </span></div><div class="line"><span class="function">        <span class="keyword">throws</span> IOExcetpion </span>&#123;</div><div class="line">        将name实例变量值反转后写入二进制流</div><div class="line">        out.writeObject(<span class="keyword">new</span> StringBuffer(name).reverse());</div><div class="line">        out.writeInt(age);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> </span></div><div class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">this</span>.name = ((StringBuffer)in.readObject()).reverse().toString();        </div><div class="line">        <span class="keyword">this</span>.age = in.readInt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<!--### 通过实现Externalizable接口实现序列化-->
<h3 id="序列化版本"><a href="#序列化版本" class="headerlink" title="序列化版本"></a>序列化版本</h3><p>反序列化Java对象必须提供该对象class文件，随着项目的升级，系统的class文件也会升级，Java如何保证两个class文件的兼容性？<br>Java序列化机制润徐为序列化类提供一个private static final的serialVersionUID值，该类变量的值用于表示Java类的序列化版本。分配serialVersionUID类变量的值非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">512L</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Java新IO的概念和作用"><a href="#Java新IO的概念和作用" class="headerlink" title="Java新IO的概念和作用"></a>Java新IO的概念和作用</h3><p>前面所讲的输入/输出流都是阻塞式的输入/输出。传统的输入/输出流都是通过字节的移动来处理，效率不高。在JDK1.4，Java提供了额一系列改进的输入/输出处理的新功能，这些功能被称为NIO(New IO)。<br>NIO采用内存映射文件的方式处理输入/输出，新IO将文件或文件的一段映射到内存中。Channel(通道)和Buffer(缓冲)是新IO的两个核心对象。<br>Channel是对传统的输入/输出的模拟，在NIO中所有的数据都是通过通道来传输;Channel与传统的InputStream、OutputStream的最大区别它提供了一个map()方法，通过map()方法直接将”一块数据”映射到内存中。如果说传统的IO是面向流的处理，则NIO是面向块的处理。<br>Buffer可以理解成是一个容器，本质是一个数组，Channel读取写入都要通过Buffer进行，Channel也可以直接将文件的某块数据映射成Buffer。<br>除此之外，NIO还提供用于将Unicode字符串映射成字节序列及逆映射操作的Charset类，也提供了支持非阻塞式的输入/输出Selector类。</p>
<h3 id="使用Buffer和Channel完成输入、输出"><a href="#使用Buffer和Channel完成输入、输出" class="headerlink" title="使用Buffer和Channel完成输入、输出"></a>使用Buffer和Channel完成输入、输出</h3><p>Buffer是一个抽象类，最常用的子类是ByteBuffer，还包括其他基本数据类型的Buffer类：CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们可以在底层字节数组上进行get、set操作。这些Buffer类没有提供构造器，通过如下方法得到Buffer对象。</p>
<blockquote>
<p>static XxxBuffer allocate(int capacity):创建一个容量capacity的XxxBuffer对象。</p>
</blockquote>
<p>Buffer中有三个重要概念：容量(capacity)、界限(limit)和位置(position)</p>
<blockquote>
<ol>
<li>容量(capacity):表示该Buffer的最大数据容量。不可为负值，创建后不可改变</li>
<li>界限(limit): 第一个不应该被读出或写入缓冲区位置索引，就是说，limit后的数据既不可读也不可写</li>
<li>位置(position): 用于致命下一个可以被读出或写入缓冲区的位置索引(类似IO流中的记录指针)<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-12-01.png" alt=""></li>
</ol>
</blockquote>
<p>Buffer的主要作用就是装入数据，初始化的时候position为0，limit为capacity,通过put()方法放入数据，position相应后移。装载数据结束，调用filip()方法，将limit设置为position所在的位置为输出做准备；当输出结束后，调用clear()方法，clear不清空数据，仅仅将position为0，limit为capacity,为再次装入数据准备;<br>Buffer包含的常用方法:</p>
<blockquote>
<ol>
<li>int capacity(): 返回Buffer的capactiy的大小</li>
<li>boolean hasRemaining(): 判断当前位置(position)和界限(limit)之间是否还有元素可提供</li>
<li>int limit():返回界面(limit)的位置</li>
<li>Buffer limit(int newLt): 从新设置界限(limit)的值，并返回一个具有新的limit的缓冲区对象</li>
<li>Buffer mark():设置mark的位置，他只能在0和位置(position)之间做mark</li>
<li>int position(): 返回position()值</li>
<li>Buffer position(int newPs): 设置Buffer的position,并返回position修改后的Buffer对象</li>
<li>Buffer reset(): 将position转到mark所在的位置</li>
<li>Buffer rewind():将position设置成0，取消设置的mark</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">CharBuffer buff = CharBuffer.allocate(<span class="number">8</span>);</div><div class="line">System.out.println(buff.capacity()); <span class="comment">//8</span></div><div class="line">System.out.println(buff.limit());    <span class="comment">//8</span></div><div class="line">System.out.println(buff.position()); <span class="comment">//0</span></div><div class="line"></div><div class="line">buff.put(<span class="string">'a'</span>);</div><div class="line">buff.put(<span class="string">'b'</span>);</div><div class="line">buff.put(<span class="string">'c'</span>);</div><div class="line">System.out.println(buff.position()); <span class="comment">//3</span></div><div class="line">buff.flip();</div><div class="line">System.out.println(buff.limit()); <span class="comment">//3</span></div><div class="line">System.out.println(buff.position()); <span class="comment">//0</span></div><div class="line"></div><div class="line"><span class="comment">//取出元素</span></div><div class="line">System.out.println(buff.get());<span class="comment">//get使position+1</span></div><div class="line">System.out.println(buff.position()); <span class="comment">// 0</span></div><div class="line">buff.clear();</div><div class="line">System.out.println(buff.capacity()); <span class="comment">//8</span></div><div class="line">System.out.println(buff.limit()); <span class="comment">//8</span></div><div class="line">System.out.println(buff.position()); <span class="comment">//0</span></div><div class="line">System.out.println(buff.get(<span class="number">2</span>)); <span class="comment">//缓冲区的内容并没有被清除</span></div><div class="line">System.out.println(buff.position()); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>Channel类似传统的流对象，与传统的流对象有两个主要区别</p>
<blockquote>
<ol>
<li>Channel可以直接将文件部分或全部直接映射成Buffer</li>
<li>程序不能直接访问Channel中的数据，只能通过Buffer进行交互</li>
</ol>
</blockquote>
<p>Java为Channel接口提供了DatagramChannel、FileChannel、Pipe.SinkChannel、PipSourceChannel、SelectableChannel、ServerSocketChannel、SocketChannel等实现类。所有的Channel不应该通过构造器创建，而是通过传统节点InputStream/OutpuStream的getChannel()方法获得，不同节点流获得的Channel不一样。Channel最常用的map()、read()和write();map()方法第一个参数执行映射时的模式分别有只读、读写等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"src/Main.java"</span>);</div><div class="line">System.out.println(f.getAbsolutePath());</div><div class="line"><span class="keyword">try</span> (</div><div class="line">    FileChannel inChannel = <span class="keyword">new</span> FileInputStream(f).getChannel();</div><div class="line">    FileChannel outChannel = <span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>).getChannel()</div><div class="line">)</div><div class="line">&#123;</div><div class="line">    MappedByteBuffer buffer = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, f.length());</div><div class="line">    outChannel.write(buffer);</div><div class="line">    buffer.clear();</div><div class="line">    Charset charset = Charset.forName(<span class="string">"utf-8"</span>);</div><div class="line">    CharsetDecoder decoder = charset.newDecoder();</div><div class="line">    CharBuffer charBuffer = decoder.decode(buffer);</div><div class="line">    System.out.println(charBuffer);</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Charset的功能和用法"><a href="#Charset的功能和用法" class="headerlink" title="Charset的功能和用法"></a>Charset的功能和用法</h3><p>Charset类处理字节序列和字符系列之间的转换关系，该类包含了用于创建解码器和编码器的方法，还提供了Carset所支持字符集的方法，Charset类是不可变的<br>Carset了提供了一个availableCharsets()静态方法获取当前JDK所支持所有的字符集。<br>Charset类提供将ByteBuffer转换成CharBuffer的功能</p>
<blockquote>
<ol>
<li>CharBuffer decode(ByteBuffer bb): 将ByteBuffer中的字节序列转换成字符序列</li>
<li>ByteBuffer encode(CharBuffer cb): 将CharBuffer中字符序列转换成字节序列</li>
<li>ByteBuffer encode(String str):将字符序列转换成字节序列的便捷方法</li>
</ol>
</blockquote>
<h3 id="FileLock的功能和用法"><a href="#FileLock的功能和用法" class="headerlink" title="FileLock的功能和用法"></a>FileLock的功能和用法</h3><p>如果多个运行程序需要并发修改同一个文件，使用文件锁可以有效的阻止多个进行并发修改同一个文件。文件锁控制文件的全部或部分字节的访问。在NIO中，Java提供了FileLock来支持文件锁定功能，在FileChannel中提供的lock()/tryLock()方法可以获得文件锁FileLock对象，从而锁定文件。lock()和tryLock()方法的区别: lock()试图锁定文件，如果无法得到文件锁，程序一直阻塞。而tryLock()尝试锁定文件，它将直接返回而不阻塞。如故宫FileChannel只想锁住文件的部分内容而不是全部内容，则可以使用如下lock()或tryLock()方法：</p>
<blockquote>
<ol>
<li>lock(long position, long size, boolean shared):对文件从position开始，长度size的内容加锁，阻塞式</li>
<li>tryLock(long position, long size, boolean shared):对文件从position开始，长度size的内容加锁，非阻塞式</li>
</ol>
</blockquote>
<!--### NIO.2的文件IO和文件系统-->
<!--### 通过NIO.2监控文件变化-->
<!--### 通过NIO.2访问、修改文件属性-->
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>几乎所有的操作系统都支持进程的概念，所有运行中的任务通常对应一个进程。进程是处于运行过程中的程序，并具有一定的独立功能，进程是系统进行资源分配和调度的一个独立单元。线程被称作轻量级进程，是进程的执行单元，就像进程在操作系统中的地位一样。线程在程序中是独立的、并发的执行流。 当进程被初始化后，主线程就被创建。<br>线程是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有父进程。线程可以拥有自己的堆栈、程序计数器和局部变量，但不拥有系统资源，它与父进程的其他线程共享该进程的全部资源。<br>线程可以与其他线程共享父进程的共享变量及部分环境，相互之间可以协同来完成进程的任务<br>线程是独立运行的，它并不知道进程中是否还有其他线程的存在。线程的执行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另一个线程可以运行。<br>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发。<br>简而言之，一个程序运行后至少有一个进程，一个进程可以包含多个线程，但至少包含一个线程。</p>
<p>多线程编程具有如下几个优点：</p>
<blockquote>
<ol>
<li>进程之间不能共享内存，但线程之间共享内存非常容易</li>
<li>系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程来实现多任务比并发多进程的效率高</li>
<li>Java语言内置了多线程功能支持，而不是单纯地作为地城操作系统的调度方式，从而简化了Java的多线程编程。</li>
</ol>
</blockquote>
<h3 id="两种创建线程的方式"><a href="#两种创建线程的方式" class="headerlink" title="两种创建线程的方式"></a>两种创建线程的方式</h3><p>Java使用Thread类代表线程，所有的线程对象都必须是Thread类或者其子类的实例。<br>继承Thread类创建线程类:</p>
<blockquote>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务。run()方法称为线程执行体</li>
<li>创建Thread子类的实例</li>
<li>调用线程对象的start()方法启动</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        <span class="comment">//getName()返回当前线程的名字</span></div><div class="line">            System.out.println(getName() + <span class="string">" "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</div><div class="line">                <span class="keyword">new</span> FirstThread().start();</div><div class="line">                <span class="keyword">new</span> FirstThread().start();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现Runnable接口创建线程类</p>
<blockquote>
<ol>
<li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</div><div class="line">                SecondThread st = <span class="keyword">new</span> SecondThread();</div><div class="line">                <span class="keyword">new</span> Thread(st, <span class="string">"新线程1"</span>).start();</div><div class="line">                <span class="keyword">new</span> Thread(st, <span class="string">"新线程2"</span>).start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用Callable和Future创建线程:<br>Java5开始,提供了Callable接口，Callable接口提供call()方法作为线程执行提，但call()比run()方法功能更强大。一、call()方法可以有返回值; 二、call()方法可以声明抛出异常; 如何使用Callable接口呢？ Java5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供一个FutureTask实现类，该实现类实现Future接口和Runnable接口，可以作为Thread类的target。<br>在Future接口里定义了如下几个公共方法控制它关联的Callable任务：</p>
<blockquote>
<ol>
<li>boolean cancel(boolean mayInterruptIfRunning):视图取消该Future里关联的Callable任务</li>
<li>V get(): 返回Callable任务里call()方法的返回值。调用该方法将阻塞程序，必须等到子线程结束后才会得到返回值</li>
<li>V get(long timeout, TimeUnit unit):返回Callable任务里call()方法的返回值。该方法最多让程序阻塞timeout和unit指定的时间，如果指定时间内没有返回值，将抛出TimeoutException异常</li>
<li>boolean isCancelled(): 如果Callable任务正常完成前被取消，返回true</li>
<li>boolean isDone(): 如果Callable任务已完成，则返回true</li>
</ol>
</blockquote>
<p>创建并启动有返回值的线程的步骤如下</p>
<blockquote>
<ol>
<li>创阿金Callable接口的实现类，并实现call()方法，该call()方法作为线程执行体，且call()方法有返回值，在创建Callble实现类的实例。Java8可以直接使用Lambda表示式创建Callable对象 </li>
<li>使用FutureTask类包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程</li>
<li>调用FutureTask对象的get()方法获得子线程执行结束后的返回值</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdThread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ThirdThread rt = <span class="keyword">new</span> ThirdThread();</div><div class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)() -&gt; &#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"的循环变量i的值"</span> + i);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"的循环变量i的值"</span> + i);</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</div><div class="line">                <span class="keyword">new</span> Thread(task, <span class="string">"有返回值的线程"</span>).start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"子线程的返回值:"</span> + task.get());</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用继承Thread类的方式创建多线程的优缺点:</p>
<blockquote>
<ol>
<li>缺点: 继承了Thread类，无法继承其他父类</li>
<li>优点: 编写简单，如果访问当前线程直接使用this即可</li>
</ol>
</blockquote>
<p>采用实现Runnable、Callable接口的方式创建多线程的优缺点:</p>
<blockquote>
<ol>
<li>优点: 线程只实现了接口，还可以继承其他类</li>
<li>优点: 多线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的</li>
<li>缺点: 编程稍稍复杂，如果需要访问当前线程则必须Thread.currentThread()方法</li>
</ol>
</blockquote>
<!--### 线程的run()方法和start()方法的区别与联系-->
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程的声明周期：新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)、死亡(Dead)5中状态。</p>
<blockquote>
<ol>
<li>新建: 当程序使用new关键字创建线程后，该线程处于新建状态</li>
<li>就绪: 当线程对象调用start()方法后，该线程处于就绪状态，处于这个状态的线程并没有运行，只是表示该线程可以运行了。何时运行? 取决JVM里线程调度器的调度</li>
<li>运行: 处于就绪状态的线程获得了CPU,开始执行run()方法的线程执行体，则线程处于运行状态。</li>
<li>阻塞: 当运行状态的线程发生了变化，会进入阻塞状态。 当阻塞状态解除后，进入就绪状态</li>
<li>死亡: 当线程执行完毕或者抛出未捕获的异常，或者调用该线程的stop()方法结束线程，就进入死亡状态</li>
</ol>
</blockquote>
<p>当发生如下情况，线程将会进入阻塞状态</p>
<blockquote>
<ol>
<li>线程调用sleep()方法，主动放弃所占有的处理器资源</li>
<li>线程调用了一个阻塞时IO方法，在该方法返回之前，该线程被阻塞</li>
<li>线程试图获得一个同步监视器，但该监视器正被其他线程持有。</li>
<li>线程正在等待某个通知</li>
<li>程序调用了线程的suspend()方法将该线程挂起。这个方法容易导致死锁。</li>
</ol>
</blockquote>
<p><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-12-02.png" alt=""></p>
<h3 id="控制线程的常用方法"><a href="#控制线程的常用方法" class="headerlink" title="控制线程的常用方法"></a>控制线程的常用方法</h3><p>join线程: Thread提供让一个线程等待另一个线程完成的方法——join()方法。当程序执行流中调用其他线程的join()方法，调用线程将被阻塞，知道join()方法加入的join线程执行完毕。join()方法有如下三种重载形式:</p>
<blockquote>
<ol>
<li>join(): 等待join的线程执行完成</li>
<li>join(long millis):等待join的线程最大时间是millis毫秒</li>
<li>join(long millis, int nanos): 等待join的线程时间最长为millis毫秒加nanos毫微秒</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            System.out.println(getName() + <span class="string">" "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> JoinThread(<span class="string">"新线程"</span>).start();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</div><div class="line">                JoinThread jt = <span class="keyword">new</span> JoinThread(<span class="string">"被Join的线程"</span>);</div><div class="line">                jt.start();</div><div class="line">                <span class="comment">//必须等待jt执行结束才会向下执行</span></div><div class="line">                jt.join();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后台线程:有一种线程，他是在后台运行，他的任务是为其他的线程提供服务; JVM的垃圾回收线程就是典型的后台线程。后台线程有个特征: 所有前台线程都死亡，后台线程会自动死亡;调用Thread对象的setDaemon(true)方法可将指定线程设置成后台线程。通过isDaemon()方法用于判断指定线程是否是后台线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            System.out.println(getName() + <span class="string">" "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        DaemonThread t = <span class="keyword">new</span> DaemonThread();</div><div class="line">        <span class="comment">//将此线程设置为后台线程</span></div><div class="line">        t.setDaemon(<span class="keyword">true</span>);</div><div class="line">        t.start();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//前台线程(main线程)结束</span></div><div class="line">        <span class="comment">//后台线程也随之结束</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程睡眠:如果要线程暂停一段时间并进入阻塞状态，则可以调用静态方法sleep()方法实现。sleep()方法有两种重载形式:</p>
<blockquote>
<ol>
<li>static void sleep(long millis): 让当前执行的线程暂停millis毫秒，并进入阻塞状态</li>
<li>static void sleep(long millis, int nanos):让当前执行的线程暂停millis毫秒加nanos毫微秒，并进入阻塞状态</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        System.out.println(<span class="string">"当前时间: "</span> + <span class="keyword">new</span> Date());</div><div class="line">        <span class="comment">//当前线程暂停1s</span></div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程让步: yield()与sleep()方法相似，但是yield()方法可以让 当前线程暂停一下，不会进入阻塞状态，转而进入就绪状态。当某个线程调用yield()方法让出CPU,只有优先级比它高的或者同等级的才会获得执行机会。</p>
<p>改变线程优先级: 每个线程都有一定的优先级，优先级高的获得比较多的执行机会。每个线程的优先级默认与创建他的父线程的优先级相同。Thread类提供了setPriority(int new Priority)、getPriority()方法来设置获取指定线程的优先级，范围是1~10;也可以使用静态常量设置:</p>
<blockquote>
<ol>
<li>MAX_PRIORITY: 其值是10</li>
<li>MIN_PRIORITY: 其值是1</li>
<li>NORM_PRIORITY: 其值是5</li>
</ol>
</blockquote>
<h3 id="线程同步的概念和必要性"><a href="#线程同步的概念和必要性" class="headerlink" title="线程同步的概念和必要性"></a>线程同步的概念和必要性</h3><p>当多个线程访问同一个数据时，容易出现线程安全问题。为了解决这个问题，Java的多线程支持引入了同步监视器来解决这个问题。</p>
<h3 id="使用synchronized控制线程同步"><a href="#使用synchronized控制线程同步" class="headerlink" title="使用synchronized控制线程同步"></a>使用synchronized控制线程同步</h3><p>使用synchronized同步代码块的语法的语法格式如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(obj) &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="comment">//此处的代码就是同步代码块</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&gt; 任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完后，该线程会释放对该同步监视器的锁定。</div></pre></td></tr></table></figure></p>
<p>与同步代码块对应的还有同步方法，同步方法使用synchronized关键字来修饰某个方法，则该方法称为同步方法。通过使用同步方法可以非常方便的实现线程安全的类，线程安全的类具有如下特征:</p>
<blockquote>
<ol>
<li>该类的对象可以被多个线程安全访问</li>
<li>每个线程调用对象的任一方法之后都将得到正确结果</li>
<li>每个线程调用该对象的任意方法之后，该对象状态依然保持合理状态</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个就是同步方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span> </span>&#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法使用了synchronized关键字修饰，把该方法变成同步方法，该同步方法的同步监视器视是this,因此任意时刻只能有一个线程进入draw方法进行操作。</p>
<p>任何线程进入同步代码块、同步方法之前，必须先获得对同步监视的锁定，何时释放对同步监视器的锁定呢？ 程序无法显示释放对同步监视器的锁定，线程会在如下几种情况释放对同步监视器的锁定:</p>
<blockquote>
<ol>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步方法、同步代码块遇到break、return终止执行</li>
<li>当前线程在同步代码块、同步方法出现了未处理的Erro或Exception,导致了该代码块、该方法异常结束</li>
<li>当前线程执行同步方法或代码块时，程序执行了同步监视器对象wait()方法，则当前线程暂停。并释放同步监视器</li>
<li>线程执行同步方法、代码块时，程序调用了Thread.sleep()/Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放同步监视器。</li>
</ol>
</blockquote>
<h3 id="使用Lock对象控制线程同步"><a href="#使用Lock对象控制线程同步" class="headerlink" title="使用Lock对象控制线程同步"></a>使用Lock对象控制线程同步</h3><p>Java5开始，Java提供了一种功能更强大的线程同步机制——通过显示定义同步锁来实现同步，同步锁有Lock对象充当。Lock、ReadWriteLock(读写锁)是Java5提供的两个根接口，并未Lock提供了ReentrantLock(可重入锁)实现类，为ReadWriteLock提供了ReentrantReadWriteLock实现类。<br>在实现线程安全的控制中，比较常用的是ReentrantLock(可重入锁).使用Lock对象可以显示的加锁、释放锁。通常使用ReentrantLock的代码格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</div><div class="line">    <span class="comment">//定义锁对象</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="comment">//定义需要保证线程安全的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//加锁</span></div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">//需要保证线程安全的代码</span></div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//使用finally块来保证释放锁</span></div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ReentrantLock锁具有可重入性，也就是说，一个线程可以对已被加锁的ReentrantLock锁再次加锁，ReentrantLock对象会维持一个计数器来追踪lock()方法的嵌套使用。线程每次调用lock()加锁后，必须显示调用unlock()来释放锁</p>
<h3 id="使用Object提供的方法实现线程通信"><a href="#使用Object提供的方法实现线程通信" class="headerlink" title="使用Object提供的方法实现线程通信"></a>使用Object提供的方法实现线程通信</h3><p>当线程在系统内运行时，线程的调度具有一定的透明性，程序通常无法准去控制线程的轮换执行，但Java也提供了一些机制来保证线程协调运行。为了实现这种功能，Object类提供了wait()、notify()、notifyAll()三个方法,但这三个方法必须有同步监视器对象来调用:同步方法或者同步代码块。</p>
<blockquote>
<ol>
<li>wait(): 导致当前线程等待，知道其他线程调用同步监视器的notify()活notifyAll()方法来唤醒该线程。该wait(): 方法有三种形式——无时间参数、带毫秒参数、带毫秒和毫微妙参数</li>
<li>notify():唤醒再次同步监视器上等待的单个线程，如果所有线程都在同步监视器上等待，则会选择唤醒其中一个线程。选择是任意性的。</li>
<li>notifyAll(): 唤醒在此同步监视器上等待的所有线程。</li>
</ol>
</blockquote>
<h3 id="使用Condition-条件变量-实现线程通信"><a href="#使用Condition-条件变量-实现线程通信" class="headerlink" title="使用Condition(条件变量)实现线程通信"></a>使用Condition(条件变量)实现线程通信</h3><p>如果程序没有使用synchronized关键字保证同步，就无法使用wait()、notify()、notifyAll()方法。当使用Lock对象保证同步，Java提供Condition类保持协调，Condition可以让那些已经得到Lock对象却无法继续执行的线程使用Lock对象，COndition对象也可以唤醒其他处于等待的线程。<br>Condition类提供了如下三个方法:</p>
<blockquote>
<ol>
<li>await(): 类似隐式同步监视器的wait()方法，导致当前线程等待，知道其他线程调用该Condition的signal或者signalAll方法</li>
<li>signal():唤醒在此Lock对象上等待的单个线程。果所有线程都在等待，则会选择唤醒其中一个线程。选择是任意性的。</li>
<li>signalAll():唤醒在此等待的所有线程。</li>
</ol>
</blockquote>
<p>Java使用ThreadGroup来表示线程组，可以对一批线程进行分类管理，Java程序允许直接对线程组进行控制。默认情况下，子线程和创建他的父线程处于同一个线程组内。<br>一旦某个线程加入指定的线程组之后，该线程一直属于该线程组，直到线程死亡，线程中途不能改变它所属的线程组。<br>Thread类提供了如下构造器设置新创建的线程属于哪个线程组:</p>
<blockquote>
<ol>
<li>Thread(ThreadGroup group, Runnable target)</li>
<li>Thread(ThreadGroup group, Runnable target, String name):以target的run()方法作为线程执行体创建新县城，该线程属于group线程组，线程名name</li>
<li>Threag(ThreadGroup group, String name): 创建新线程，线程名name，属于group线程组</li>
</ol>
</blockquote>
<p>ThreadGroup类提供了两个简单的构造器创建实例</p>
<blockquote>
<ol>
<li>ThreadGroup(String name):以指定线程组名字创建</li>
<li>ThreadGroup(ThreadGroup parent, String name): 以指定名字、指定父类创建一个新线程组</li>
</ol>
</blockquote>
<p>ThreadGroup类提供了如下几个常用方法:</p>
<blockquote>
<ol>
<li>int activeCount(): 返回线程组中活动线程数目 </li>
<li>interrupt(): 中断此线程中所有线层</li>
<li>isDaemon():判断线程组中是否是后台线程组</li>
<li>setDaemon(boolean daemon): 把该线程组设置成后台线程组</li>
<li>setMaxPriority(int pri): 设置线程组的最高优先级</li>
</ol>
</blockquote>
<h3 id="线程池的功能和用法"><a href="#线程池的功能和用法" class="headerlink" title="线程池的功能和用法"></a>线程池的功能和用法</h3><p>系统启动一个新线程的成本较高，当程序中需要创建大量生存期短暂的线程时，应该考虑使用线程池；与数据库连接池类似，线程池在系统启动时创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池会启动一个线程执行run()或者call()方法，执行结束后，线程不会死亡，返回线程池称为空闲状态，等待执行下一个Runnable对象的run()或call()方法；</p>
<p>Java5以前，开发者必须手动实现自己的线程池；Java5开始，Java内建支持线程池，Java5新增了一个Executors工厂类产生线程池，该工厂类包含如下几个静态工厂方法创建线程池:</p>
<blockquote>
<ol>
<li>newCachedThreadPool(): 创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存在线程池中</li>
<li>newFixedThreadPool(int nThreads): 创建一个可重用的、具有固定线程数的线程池</li>
<li>newSingleThreadExecutor():创建一个只有单线程的线程池，相当于newFixedThreadPool(1)</li>
<li>newScheduledThreadPool(int corePolSize):创建具有指定线程数(corePolSize)的线程池，他可以在指定延迟后执行线程任务。</li>
<li>newSingleThreadScheduleExecutor(): 创建只有一个线程的线程池，他可以在指定延迟后执行线程任务。</li>
<li>ExecutorService newWorkStealingPool(int parallelism):创建持有足够的线程的线程池来支持给定的并行级别，该方法还会使用多个队列减少竞争</li>
<li>ExecutorService newWorkStealingPool():该方法是前一个的简化版本</li>
</ol>
</blockquote>
<p>上面7个方法前三个返回一个ExecutorService对象，该对象代表一个线程池；中间两个方法返回一个ScheduledExecutorService线程池，它是ExecutorService的子类，它可以指定延迟后执行线程任务。最后两个则是Java8新增的，这两个方法可充分利用多CPU并的能力。这两个方法生成work stealing池，都相当于后台线程池，如果所有的前台线程都死亡，work stealing池中的线程会自动死亡。<br>ExecutorService提供了如下三个方法:</p>
<blockquote>
<ol>
<li>Future&lt;?&gt; submit(Runnable task):讲一个Runnable对象提交给指定的线程池。其中Future对象代表Runnable任务的返回值。可以调用Future的isDone()、isCancelled()方法来获得Runnable对象的执行状态</li>
<li><t>Future<t> submit(Runnable task, T reslut): 将一个Runnable对象交给线程池，result显示指定线程执行结束返回值</t></t></li>
<li><t>Future<t> submit(Callable<t> task): 将一个Callable对象提交给线程池，Future是Callable的返回值</t></t></t></li>
</ol>
</blockquote>
<p>ScheduleExecutorService代表可在指定延迟后或周期性执行线程任务的线程池，它提供了如下4个方法:</p>
<blockquote>
<ol>
<li>ScheduleFuture<v> schedule(Callable<v> callable, long delay, TimeUnit unit):指定callable任务将在delay延迟后执行</v></v></li>
<li>ScheduleFuture<v> schedule(Runnable command, long delay, TimeUnit unit): 指定command任务将在delay延迟后执行</v></li>
<li>ScheduleFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit): 指定command任务将在delay延迟后执行，而且以设定频率重复执行</li>
<li>ScheduleFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit):创建并执行一个给定初始延迟后首次启用的定期操作，随后在每一次执行终止和下一次执行开始之前都存在给定延迟。如果任务遇到异常，就会取消后续执行；否在，只能通过程序来显示取消或终止该任务</li>
</ol>
</blockquote>
<!--### Java8增强的ForkJoinPool-->
<h3 id="ThreadLocal类的功能和用法"><a href="#ThreadLocal类的功能和用法" class="headerlink" title="ThreadLocal类的功能和用法"></a>ThreadLocal类的功能和用法</h3><p>ThreadLocal代表一个线程局部变量，通过把数据放在ThreadLocal中就可以让每个线程创建一个该变量的副本，从而避免线程安全问题。ThreadLocal类用法非常简单，他只提供了如下三个public方法：</p>
<blockquote>
<ol>
<li>T get(): 返回此线程局部变量中当前线程副本中的值</li>
<li>void remove(): 删除此线程局部变量中当前线程的值</li>
<li>void set(T value): 设置此线程局部变量中当前线程副本中的值</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</div><div class="line">    <span class="comment">/** 顶一个ThreadLocal类型的变量,该变量将是一个线程局部变量,每个线程都会保留该变量的一个副本 */</span></div><div class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; name = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="comment">//定义一个初始化name成员变量的构造器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name.set(str);</div><div class="line">        <span class="comment">//下面代码用于访问当前线程的name副本的值</span></div><div class="line">        System.out.println(<span class="keyword">this</span>.name.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name.set(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="comment">//定义一个Account类型的成员变量</span></div><div class="line">    <span class="keyword">private</span> Account account;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTest</span><span class="params">(Account account, String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.account = account;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">6</span>) &#123;</div><div class="line">                account.setName(getName());</div><div class="line">            &#125;</div><div class="line">            System.out.println(account.getName() + <span class="string">"账户的i值: "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Account at = <span class="keyword">new</span> Account(<span class="string">"初始名"</span>);</div><div class="line">        <span class="keyword">new</span> MyTest(at, <span class="string">"线程甲"</span>).start();</div><div class="line">        <span class="keyword">new</span> MyTest(at, <span class="string">"线程乙"</span>).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<!--### 使用线程安全的集合类-->
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础(七)]]></title>
      <url>/2017/06/07/Java%E5%9F%BA%E7%A1%80-%E4%B8%83/</url>
      <content type="html"><![CDATA[<h2 id="Annotation-注解"><a href="#Annotation-注解" class="headerlink" title="Annotation(注解)"></a>Annotation(注解)</h2><p>Annotation能被用来为程序元素(类、方法、成员变量等)设置元数据。Annotation不影响程序代码的执行，无论增加、删除Annotation。如果希望程序中Annotation在运行时起一定的租用，只有通过某种配套的工具对Annotation中的信息进行访问和处理，访问和处理Annotation的工具统称APT(Annotation Processing Tool)。<br>Java提供了5个基本的Annotation的用法——使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用。5个基本的Annotation如下：</p>
<blockquote>
<ol>
<li>@Override</li>
<li>@Deprecated</li>
<li>@SuppressWarnings</li>
<li>@safeVarargs: Java7新增</li>
<li>@FunctionalInterface: Java8新增</li>
</ol>
</blockquote>
<h3 id="Override注解的功能和用法"><a href="#Override注解的功能和用法" class="headerlink" title="@Override注解的功能和用法"></a>@Override注解的功能和用法</h3><p>@Override指定方法覆载的，强制子类必须覆盖父类的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">    <span class="comment">//使用Override指定下面方法必须重写父类方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Deprecated注解功能和用法"><a href="#Deprecated注解功能和用法" class="headerlink" title="@Deprecated注解功能和用法"></a>@Deprecated注解功能和用法</h3><p>@Deprecated表示某个程序元素(类、方法等)已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用info()方法时会被编译器警告</span></div><div class="line"><span class="keyword">new</span> Fruit().info();</div></pre></td></tr></table></figure></p>
<h3 id="SuppressWarnings注解的功能和用法"><a href="#SuppressWarnings注解的功能和用法" class="headerlink" title="@SuppressWarnings注解的功能和用法"></a>@SuppressWarnings注解的功能和用法</h3><p>@SuppressWarnings指示该注解修饰的程序元素(以及该程序元素中的所有子元素)取消显示指定的编译器警告。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//关闭整个类里的编译器警告</span></div><div class="line"><span class="meta">@SuppressWarnings</span>（value=<span class="string">"unchecked"</span>）</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupperssWarningsTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//下面会发生编译器警告，但是上面注解修饰因此看不到编译器警告</span></div><div class="line">        List&lt;String&gt; myList = <span class="keyword">new</span> ArrayList();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面代码可导致运行时异常，当把一个不带泛型的对象赋给一个带泛型的变量时，往往就会发生这种错误，Java把这种错误的原因称为”堆污染”。但有时候开发者不希望看到这个警告，则可以使用如下三种方式”抑制”这个警告。</p>
<blockquote>
<ol>
<li>使用@SafeVarargs修饰引发警告的方法或构造器</li>
<li>使用@SuppressWarnings修饰</li>
<li>编译时使用-Xlint:varargs选项</li>
</ol>
</blockquote>
<h3 id="FunctionalInterface注解的功能和用法"><a href="#FunctionalInterface注解的功能和用法" class="headerlink" title="@FunctionalInterface注解的功能和用法"></a>@FunctionalInterface注解的功能和用法</h3><p>Java8规定：如果接口中只有一个抽象方法，该接口就是函数式接口。@FunctionalInterface就是用来指定某个接口必须是函数式接口。如果使用@FunctionalInterface修饰的接口包含两个及以上会编译出错。</p>
<h3 id="Retention注解的功能和用法"><a href="#Retention注解的功能和用法" class="headerlink" title="@Retention注解的功能和用法"></a>@Retention注解的功能和用法</h3><p>@Retention只能用于修饰Annotation定义，用于指定被修饰的Annotation可以保留多长时间。@Retention的value成员变量智只能是如下三个:</p>
<blockquote>
<ol>
<li>RetentionPolicy.CLASS: 编译器把Annotation记录在class文件中。运行Java程序JVM不可获取Annotation信息。这是默认值</li>
<li>RetentionPolicy.RUNTIME:  编译器把Annotation记录在class文件中。运行Java程序JVM可获取Annotation信息。</li>
<li>RetentionPolicy.SOURCE: 编译器把Annotation只保留在源代码中。编译器直接丢弃这种Annotation。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义下面Testable Annotation保留到运行时</span></div><div class="line"><span class="meta">@Retention</span>(value=RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Testable&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="Target注解的功能和用法"><a href="#Target注解的功能和用法" class="headerlink" title="@Target注解的功能和用法"></a>@Target注解的功能和用法</h3><p>@Target只能用于修饰Annotation定义,用于指定被修饰的Annotation能用于修饰哪些程序单元。该成员变量的值如下：</p>
<blockquote>
<ol>
<li>ElementType.ANNOTATION_TYPE:该Annotation只能修饰Annotation</li>
<li>ElementType.CONSTRUCTOR:该Annotation只能修饰构造器</li>
<li>ElementType.FIELD:该Annotation只能修饰成员变量</li>
<li>ElementType.LOCAL_VARIABLE:该Annotation只能修饰局部变量</li>
<li>ElementType.METHOD:该Annotation只能修饰方法定义</li>
<li>ElementType.PACKAGE:该Annotation只能修饰包定义</li>
<li>ElementType.PARAMETER:该Annotation只能修饰参数</li>
<li>ElementType.TYPE:该Annotation只能修饰类、接口或枚举定义</li>
<li>ElementType.PARAMETER:该Annotation只能修饰参数</li>
</ol>
</blockquote>
<h3 id="Documented注解的功能和用法"><a href="#Documented注解的功能和用法" class="headerlink" title="@Documented注解的功能和用法"></a>@Documented注解的功能和用法</h3><p>@Documented用于指定该元Annotation修饰的Annotation类将被javadoc工具类提取成文档，如果定义Annotation类使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档都会包含该Annotation说明</p>
<h3 id="Inherited注解的功能和用法"><a href="#Inherited注解的功能和用法" class="headerlink" title="@Inherited注解的功能和用法"></a>@Inherited注解的功能和用法</h3><p>@Inherited用于指定该元Annotation修饰的Annotation类将具有继承性——如果某个类使用@Xxx注解修饰，则其子类将自动被@Xxx修饰。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>定义新的Annotation类型使用@interface关键字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个简单的Annotation类型</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//可以在程序任何地方使用</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Annotation还可以带成员变量，Annotation成员变量在Annotation定义中以无形参的方法形式声明，其方法名和返回值定义了该成员变量的名字和类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//设置默认值</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 32</span>;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myclass</span> </span>&#123;</div><div class="line">    <span class="meta">@Test</span>(name=<span class="string">"a"</span>, age=<span class="number">18</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据Annotation是否可以包含成员变量可以把Annotation分成两类：标记Annotation(没有定义成员变量的Annotation)，元数据Annotation(包含成员变量的Annotation)</p>
<h3 id="提取注解信息"><a href="#提取注解信息" class="headerlink" title="提取注解信息"></a>提取注解信息</h3><p>使用Annotation修饰了类、方法、成员变量等成员后，这些Annotation自己不生效，必须有开发者提供相应的工具来提取并处理Annotation信息。<br>Java5在java.lang.reflect包下新增了AnnotatedElement接口，该接口可以接受注解的程序元素。该接口主要有如下几个实现类：</p>
<blockquote>
<ol>
<li>Class: 类定义</li>
<li>Constructor: 构造器定义</li>
<li>Field:类的成员变量定义</li>
<li>Method:类的方法定义</li>
<li>Package:类的包定义</li>
</ol>
</blockquote>
<p>java.lnag.reflect包下提供了一些实现反射功能的工具类。只有当Annotation使用了运行时可见的修饰，JVM才会在装载*.class文件时读取保存在class文件中的Annotation。<br>AnnotationElement接口是所有程序元素的负借口，所以程序通过反射获取某个类的AnnotationElement对象之后，程序就可以滴啊用该方法的如下几个方法来访问Annotation信息；</p>
<blockquote>
<ol>
<li><a extends="" annotation=""> A getAnnotation(Class<a> annotationClass): 返回程序元素上存在的、指定类型的注解，不存在返回null</a></a></li>
<li><a extends="" annotation=""> A getDeclaredAnnotation(Class<a> annotationClass): Java8新增方法，该方法尝试获取直接修饰该程序元素、指定类型的Annotation。</a></a></li>
<li>Annotation[] getAnnotations(): 返回程序元素上存在的所有注解</li>
<li>Annotation[] getDeclaredAnnotations():返回直接修饰该元素的所有Annotation</li>
<li>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass): 判断该程序元素上是否存在指定类型的注解</li>
<li><a extends="" annotation=""> A[] getAnnotationByType(Class<a> annotationClass):该方法与getAnnotation类似，Java8增加了重复注解功能，使用该方法修饰该程序元素、指定类型的多个Annotation</a></a></li>
<li><a extends="" annotation=""> A[] getDeclaredAnnotationByType(Class<a> annotationClass):该方法与getDeclaredAnnotation类似，Java8增加了重复注解功能，使用该方法修饰该程序元素、指定类型的多个Annotation</a></a></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取Test类的info方法的所有注解</span></div><div class="line">Annotation[] aArray = Class.forName(<span class="string">"Test"</span>).getMethod(<span class="string">"info"</span>).getAnnotations();</div><div class="line"><span class="comment">//遍历注解</span></div><div class="line"><span class="keyword">for</span> (Annotation an : aArray) &#123;</div><div class="line">    <span class="keyword">if</span> (an <span class="keyword">instanceof</span> Test) &#123;</div><div class="line">        <span class="comment">//将an强制转换成Test</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<!--### 重复注解

### Type Annotation
-->
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础(六)]]></title>
      <url>/2017/06/06/Java%E5%9F%BA%E7%A1%80-%E5%85%AD/</url>
      <content type="html"><![CDATA[<h2 id="MySQL数据库与JDBC编程"><a href="#MySQL数据库与JDBC编程" class="headerlink" title="MySQL数据库与JDBC编程"></a>MySQL数据库与JDBC编程</h2><p>通过JDBC，Java程序可以方便操作各种主流数据库。程序使用JDBC API以统一的方式来连接不同的数据库，然后通过Statement对象来执行标准的SQL语句，获得SQL语句访问数据库的结果。因此掌握标准的SQL语句是学习JDBC的基础。</p>
<blockquote>
<p>因为数据库系统太多了并且各数据库内部特性不同，所以Sun就定制了一组标准API,他们只是接口，没有提供实现类——这些实现类有数据库厂商提供实现，这些实现类就是驱动程序。</p>
</blockquote>
<p>Sun提供的JDBC可以完成以下三个基本工作:</p>
<blockquote>
<ol>
<li>建立与数据库的连接</li>
<li>执行SQL语句</li>
<li>获得SQL语句的执行结果</li>
</ol>
</blockquote>
<h3 id="JDBC数据库编程步骤"><a href="#JDBC数据库编程步骤" class="headerlink" title="JDBC数据库编程步骤"></a>JDBC数据库编程步骤</h3><p>JDBC常用的API:</p>
<blockquote>
<ol>
<li><p>DriverManager: 用户管理JDBC驱动的服务类。主要功能获取Connection对象。该类包含方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该方法获得url对应的数据库连接</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></div><div class="line"><span class="function"><span class="params">        java.util.Properties info)</span> <span class="keyword">throws</span> SQLException</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>Connection:代表数据库连接对象，每个Connection代表一个物理连接会话。该方法常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回一个Statement对象</span></div><div class="line"><span class="function">Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//返回预编译的Statement对象，即将SQL语句提交到数据库进行预编译</span></div><div class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//返回CallableStatement对象，该对象用于调用存储过程</span></div><div class="line"><span class="function">CallableStatement <span class="title">prepareCall</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//上面都是用于执行sql语句返回的Statment对象，CallableStatement、PreparedStatement是Statment的子类</span></div><div class="line"></div><div class="line"><span class="comment">//控制事务的几个方法</span></div><div class="line"><span class="comment">//创建一个保存点</span></div><div class="line"><span class="function">Savepoint <span class="title">setSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//指定名字创建保存点</span></div><div class="line"><span class="function">Savepoint <span class="title">setSavepoint</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//设置事务的隔离级别</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTransactionIsolation</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//事务回滚</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//事务回滚到指定保存点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(Savepoint savepoint)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//关闭自动提交，打开事务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//提交事务</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>Statement:用于执行SQL语句的工具接口。该对象可执行DDL、DCL、SQL查询。常用方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行查询语句，并返回对应的ResultSet对象</span></div><div class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//用于执行DML,并返回受影响的行数；该方法也可执行DDL，执行DDL返回0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//执行任何sql语句，如果第一个结果是ResultSet返回true,如果第一个结果是受影响的行数或者没有任何结果返回false</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>PreparedStatement:预编译的Statement对象，PreparedStatement是Statment子接口，它允许数据库预编译sql语句，以后每次只改变sql命令的参数，避免数据库每次都需要编译sql语句，因此性能更好。他比Statement多了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setXxx</span><span class="params">(<span class="keyword">int</span> paramentIndex, Xxx value)</span>:根据传入的类型不同，调用不同的方法</span></div></pre></td></tr></table></figure>
</li>
<li><p>ResultSet:结果集对象。该对象包含访问查询结果的方法，ResultSet可以通过列索引或列名获得列数据。它包含如下方法来移动记录指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//释放ResultSet对象</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//将结果集的指针移动到第row行，如果row是负数，则移动到倒数第row行。</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">absolute</span><span class="params">( <span class="keyword">int</span> row )</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//将记录指针定位到第一行之前，也就是初始状态</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeFirst</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//将指针定位到第一行</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//将记录指针定位到上一行</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">previous</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//将记录指针定位到下一行</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//将记录指针定位到最后一行</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">last</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</div><div class="line"><span class="comment">//将记录指针定位到最后一行之后</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterLast</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>JDBC的编程步骤大致如下：</p>
<blockquote>
<ol>
<li>加载驱动。通常使用Class类的forName()静态方法加载驱动</li>
<li>通过Drivermanager获取数据连接Connection对象</li>
<li>通过Connection对象创建Statement对象</li>
<li>使用Statement执行SQL语句</li>
<li>操作结果集</li>
<li>回收数据库资源，包括关闭ResultSet、Statement和Connection等资源</li>
</ol>
</blockquote>
<p>使用execute()方法执行sql语句，该结果只返回boolean值，如果返回了ResultSet对象。那么怎么得到ResultSet对象？</p>
<blockquote>
<ol>
<li>getResultSet():获取Sstatement执行查询语句返回的ResultSet对象</li>
<li>getUpdateCount(): 获取Sstatement执行DML语句所影响的记录行数</li>
</ol>
</blockquote>
<h3 id="使用PreparedStatement执行SQL语句"><a href="#使用PreparedStatement执行SQL语句" class="headerlink" title="使用PreparedStatement执行SQL语句"></a>使用PreparedStatement执行SQL语句</h3><p>PreparedStatement可以使用占位符(?)。使用PreparedStatement比使用Statement多了如下三个好处:</p>
<blockquote>
<ol>
<li>PreparedStatement预编译SQL语句，性能更好</li>
<li>PreparedStatement无须”拼接”SQL语句</li>
<li>PreparedStatement可以避免SQL注入，安全性更好</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String driver;</div><div class="line">    <span class="keyword">private</span> String url;</div><div class="line">    <span class="keyword">private</span> String user;</div><div class="line">    <span class="keyword">private</span> String pass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initParam</span><span class="params">(String paramFile)</span><span class="keyword">throws</span>  Exception </span>&#123;</div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.load(<span class="keyword">new</span> FileInputStream(paramFile));</div><div class="line">        driver = props.getProperty(<span class="string">"driver"</span>);</div><div class="line">        url = props.getProperty(<span class="string">"url"</span>);</div><div class="line">        user = props.getProperty(<span class="string">"user"</span>);</div><div class="line">        pass = props.getProperty(<span class="string">"pass"</span>);</div><div class="line">        <span class="comment">//加载驱动</span></div><div class="line">        Class.forName(driver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUsePrepare</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> (</div><div class="line">                <span class="comment">//获取数据库链接</span></div><div class="line">                Connection conn = DriverManager.getConnection(url, user, pass);</div><div class="line">                <span class="comment">//使用Connection创建PreparedStatement对象</span></div><div class="line">                PreparedStatement pstmt = conn.prepareStatement(<span class="string">"insert into student_table values(null, ?, 1)"</span>)</div><div class="line">            )</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//循环出入100条记录</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                pstmt.setString(<span class="number">1</span>, <span class="string">"姓名"</span> + i);</div><div class="line">                pstmt.executeUpdate();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用CallableStatement调用存储过程"><a href="#使用CallableStatement调用存储过程" class="headerlink" title="使用CallableStatement调用存储过程"></a>使用CallableStatement调用存储过程</h3><p>下面是SQL语句在MySQL数据库创建的简单的存储过程，其中参数sum用out修饰，是返回数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">delimiter <span class="comment">//</span></div><div class="line"><span class="function">create procedure <span class="title">add_pro</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, out sum <span class="keyword">int</span>)</span></span></div><div class="line"><span class="function">begin</span></div><div class="line"><span class="function">set sum </span>= a + b;</div><div class="line">end; </div><div class="line"><span class="comment">//</span></div></pre></td></tr></table></figure></p>
<p>调用存储过程使用CallableStatement对象，通过Connection的prepareCall()方法创建CallableStatement对象，创建对象需传入调用存储过程的SQL语句，其格式:{call 过程名(?,?,?…)}<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String driver;</div><div class="line">    <span class="keyword">private</span> String url;</div><div class="line">    <span class="keyword">private</span> String user;</div><div class="line">    <span class="keyword">private</span> String pass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initParam</span><span class="params">(String paramFile)</span><span class="keyword">throws</span>  Exception </span>&#123;</div><div class="line">        Properties props = <span class="keyword">new</span> Properties();</div><div class="line">        props.load(<span class="keyword">new</span> FileInputStream(paramFile));</div><div class="line">        driver = props.getProperty(<span class="string">"driver"</span>);</div><div class="line">        url = props.getProperty(<span class="string">"url"</span>);</div><div class="line">        user = props.getProperty(<span class="string">"user"</span>);</div><div class="line">        pass = props.getProperty(<span class="string">"pass"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callProcedure</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//加载驱动</span></div><div class="line">        Class.forName(driver);</div><div class="line">        <span class="keyword">try</span> (</div><div class="line">                <span class="comment">//获取数据库链接</span></div><div class="line">                Connection conn = DriverManager.getConnection(url, user, pass);</div><div class="line">                <span class="comment">//获取输出参宿,使用Connection创建PreparedStatement对象</span></div><div class="line">                CallableStatement cstmt = conn.prepareCall(<span class="string">"&#123;call add_pro(?,?,?)&#125;"</span>)</div><div class="line">            )</div><div class="line">        &#123;</div><div class="line">            cstmt.setInt(<span class="number">1</span>, <span class="number">4</span>);</div><div class="line">            cstmt.setInt(<span class="number">2</span>, <span class="number">5</span>);</div><div class="line">            <span class="comment">//注册CallableStatement的第三个参数是int类型</span></div><div class="line">            cstmt.registerOutParameter(<span class="number">3</span>, Types.INTEGER);</div><div class="line">            <span class="comment">//执行存储过程</span></div><div class="line">            cstmt.execute();</div><div class="line">            <span class="comment">//获取输出参数</span></div><div class="line">            cstmt.getInt(<span class="number">3</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用ResultSetMetaData分析结果集元数据"><a href="#使用ResultSetMetaData分析结果集元数据" class="headerlink" title="使用ResultSetMetaData分析结果集元数据"></a>使用ResultSetMetaData分析结果集元数据</h3><p>ResultSet封装sql查询的结果，通过记录指针取出内容。JDBC还允许ResultSet更新记录，提供ResultSetMetaData获取ResultSet对象的相关信息。<br>在JDK1.4以前，默认打开的结果集是不可滚动的，必须在创建Statement或PreparedStatement传入额外参数，在Java5.0以后默认打开的ResultSet就是可滚动的。但是默认打开的ResultSet是不可更新的，如要要创建可更新的需要出入参数。</p>
<blockquote>
<ol>
<li><p>resultSetType: 控制ResultSet类型，该参数可以取如下三个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//控制记录指针只能往前移动,JDK1.4以前的默认值</span></div><div class="line">ResultSet.TYPE_FORWARD_ONLY</div><div class="line"><span class="comment">//控制记录指针可以自由移动，但底层的改变不会影响ResultSet的内容</span></div><div class="line">ResultSet.TYPE_SCROLL_INSENSITIVE</div><div class="line"><span class="comment">//控制记录指针可以自由移动，而且底层的改变会影响ResultSet的内容</span></div><div class="line">ResultSet.TYPE_SCROLL_SENSITIVE</div></pre></td></tr></table></figure>
</li>
<li><p>resultSetConcurrency:控制ResultSet的并发类型，该参数可以接收如下两个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ResultSet是只读的并发模式</span></div><div class="line">ResultSet.CONCUR_READ_ONLY</div><div class="line"><span class="comment">//ResultSet是可更新的并发模式</span></div><div class="line">ResultSet.CONCUR_UPDATABLE</div><div class="line">``` </div><div class="line">&gt; <span class="number">3</span>. 可更新结果集必须满足如下两个条件: 所有数据来自一个表，选出的数据必须包含主键</div><div class="line"></div><div class="line">```java</div><div class="line"><span class="keyword">try</span> (</div><div class="line">                <span class="comment">//获取数据库链接</span></div><div class="line">                Connection conn = DriverManager.getConnection(url, user, pass);</div><div class="line">                PreparedStatement pstms = conn.prepareCall(sql, ResultSet.TYPE_SCROLL_INSENSITIVE,</div><div class="line">                        ResultSet.CONCUR_UPDATABLE);</div><div class="line">                ResultSet rs = pstms.executeQuery()</div><div class="line">            )</div><div class="line">        &#123;</div><div class="line">            rs.last();</div><div class="line">            <span class="comment">//修改记录指针指向的记录</span></div><div class="line">            rs.updateString(<span class="number">2</span>, <span class="string">"ddddd"</span>);</div><div class="line">            <span class="comment">//提交修改</span></div><div class="line">            rs.updateRow();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>通过ResultSet包含的getMetaData()方法获取ResultSetMetaData对象。该对象提供大量方法描述ResultSet信息。常用方法如下：</p>
<blockquote>
<ol>
<li>int getColumnCount(): 返回ResultSt的列数量</li>
<li>String getColumnName(int column):返回指定索引的列明</li>
<li>int getColumnType(int column):返回指定索引的列类型<h3 id="理解并掌握RowSet、RowSetFactory"><a href="#理解并掌握RowSet、RowSetFactory" class="headerlink" title="理解并掌握RowSet、RowSetFactory"></a>理解并掌握RowSet、RowSetFactory</h3>RowSet接口继承ResultSet接口，RowSet接口下包含JdbcRowSet、CacheRowSet、FilteredRowSet、JoinRowSet和WebRowSet常用子接口。除JdbcRowSet需要保持与数据库进行长连接之外，其他 都是离线的RowSet。RowSet默认是可滚动的、可更新、可序列化的。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-07-03.png" alt=""><br>RowSetFactory提供如下方法创建RowSet实例:</li>
<li>public CachedRowSet createCachedRowSet() throws SQLException; 创建一个默认的CachedRowSet</li>
<li>public FilteredRowSet createFilteredRowSet() throws SQLException;创建一个默认的FilteredRowSet</li>
<li>public  JdbcRowSet createJdbcRowSet() throws SQLException;创建一个默认的JdbcRowSet</li>
<li>public  JoinRowSet createJoinRowSet() throws SQLException;创建一个默认的JoinRowSet</li>
<li>public  WebRowSet createWebRowSet() throws SQLException;创建一个默认的WebRowSet<h3 id="离线RowSet"><a href="#离线RowSet" class="headerlink" title="离线RowSet"></a>离线RowSet</h3>离线RowSet会直接将底层数据读入内存中，封装成RowSet对象。CachedRowSet是所有离线RowSet的父接口。<!--### 使用RowSet控制分页-->
</li>
</ol>
</blockquote>
<h3 id="事务的基础知识"><a href="#事务的基础知识" class="headerlink" title="事务的基础知识"></a>事务的基础知识</h3><p>事务具有4个特性：原子性、一致性、隔离性、持续性；</p>
<blockquote>
<ol>
<li>原子性：事务是应用中最小的执行单位，就如原子是自然界最小颗粒，具有不可再分的特性</li>
<li>一致性：事务执行结果，必须是数据库从一个一致状态，变到另一个一致性状态。</li>
<li>隔离性：各个事务的执行互不干扰，任何一个事务的内部操作对其他并发的事务都是隔离的</li>
<li>持续性：持续性也称为持久性，指事务一旦提交，对数据所做的任何改变都要记录到永久存储器<br>事务提交的方式有两种：显示提交(commit)和自动提交(执行DDL或DCL或程序正常退出)<br>事务回滚的方式有两种：显示回滚(rollback)和自动回滚(系统错误或强制退出)<h3 id="JDBC编程中的事务控制"><a href="#JDBC编程中的事务控制" class="headerlink" title="JDBC编程中的事务控制"></a>JDBC编程中的事务控制</h3>JDBC连接提供事务支持，Connection默认打开自动提交，即关闭事务，每执行一条sql语句，就会立即提交，无法回滚。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//关闭自动提交开启事务</span></div><div class="line">conn.setAuttoCommit(<span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="comment">//提交事务</span></div><div class="line">conn.commit();</div><div class="line"></div><div class="line"><span class="comment">//事务回滚</span></div><div class="line">conn.rollback();</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<!--### 使用DatabaseMetaData分析数据库元数据-->
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>数据库连接的建立和关闭是及其耗费系统资源的操作，每次操作打开一个物理连接，使用完毕关闭连接造成系统性能低下。<br>数据连接池的解决方案：当程序启动时，创建足够的数据库连接，并将这些连接组成一个连接池。每次应用程序请求数据库，无须重新打开连接，而是从连接池取已有的使用。使用完后不关闭数据库连接，直接归还给数据库连接池，大大提高运行效率。<br>数据库常用的参数如下</p>
<blockquote>
<ol>
<li>数据库的初始连接数</li>
<li>连接池的最大连接数</li>
<li>连接池的最小连接数</li>
<li>连接池每次增加的容量</li>
</ol>
</blockquote>
<p>数据库连接池有DBCP何C3P0等开源的连接池实现。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础(五)]]></title>
      <url>/2017/06/05/Java%E5%9F%BA%E7%A1%80-%E4%BA%94/</url>
      <content type="html"><![CDATA[<h2 id="泛型入门"><a href="#泛型入门" class="headerlink" title="泛型入门"></a>泛型入门</h2><p>在没有泛型之前，Java集合把所有的元素当做Object类型处理，再次取出对象，该对象的类型就变成Object类型(运行时没变)。进行类型转换容易出现异常，并且在编译时不检查类型。在Java5以后，Java引入了”参数化类型”概念，允许在创建集合的时候指定集合元素的类型，也就是泛型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">List strList = <span class="keyword">new</span> ArrayList();</div><div class="line">strList.add(<span class="string">"疯狂Java讲义"</span>);</div><div class="line">strList.add(<span class="string">"疯狂iOS讲义"</span>);</div><div class="line">strList.add(<span class="number">5</span>);</div><div class="line"><span class="comment">//当str为5时，就会导致发生异常</span></div><div class="line">strList.forEach(str -&gt; System.out.println(((String)str).length()));</div><div class="line"></div><div class="line"><span class="comment">//泛型</span></div><div class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">strList.add(<span class="string">"疯狂Java讲义"</span>);</div><div class="line">strList.add(<span class="string">"疯狂iOS讲义"</span>);</div><div class="line">strList.add(<span class="number">5</span>);<span class="comment">//在此时引起编译错误</span></div><div class="line">strList.forEach(str -&gt; System.out.println(((String)str).length()));</div></pre></td></tr></table></figure>
<p>Java7开始，Java允许在构造器后不需要带完整的泛型信息，只要给出尖括号(&lt;&gt;)即可，Java可以推断出尖括号里面是什么泛型信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div></pre></td></tr></table></figure></p>
<h3 id="编译时类型检查的重要性"><a href="#编译时类型检查的重要性" class="headerlink" title="编译时类型检查的重要性"></a>编译时类型检查的重要性</h3><h3 id="使用泛型实现编译时进行类型检查"><a href="#使用泛型实现编译时进行类型检查" class="headerlink" title="使用泛型实现编译时进行类型检查"></a>使用泛型实现编译时进行类型检查</h3><h3 id="定义泛型接口、泛型类"><a href="#定义泛型接口、泛型类" class="headerlink" title="定义泛型接口、泛型类"></a>定义泛型接口、泛型类</h3><p>允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有课使用普通类型的地方都可以使用这种类型形参。下面是Java5改写后的List接口、Interator接口、Map接口的代码片段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义接口时指定一个类型形参,该形参名为E</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">//在该接口里，E可作为类型使用</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E x)</span></span>;</div><div class="line">    <span class="function">Interator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interator</span>&lt;<span class="title">E</span>&gt; </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">//在该接口里，E可作为类型使用</span></div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">//在该接口里，E可作为类型使用</span></div><div class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>从泛型类派生子类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继承带有泛型声明的接口、父类时，不能包含类型参数</span></div><div class="line"><span class="keyword">public</span> classA extends Apple&lt;T&gt; <span class="comment">// 编译失败</span></div><div class="line"><span class="comment">//但是可以传入一个实际的参数 </span></div><div class="line"><span class="keyword">public</span> classA extends Apple&lt;String&gt;<span class="comment">//正确的</span></div><div class="line"><span class="comment">//或者也可以什么都不传，系统会把T当做Object类型处理，但是Java编译器可能发出警告，如果希望看到警告提示更详细，可以通过javac命令增加-Xlint:unchecked选项来实现</span></div><div class="line"><span class="keyword">public</span> ClassA extends Apple</div></pre></td></tr></table></figure></p>
<h3 id="适用类型通配符"><a href="#适用类型通配符" class="headerlink" title="适用类型通配符"></a>适用类型通配符</h3><p>假设定义一个方法，方法里有一个集合，但集合元素的类型不确定，这是可以使用类型通配符，类型通配符是一个问号(?),类型通配符可以匹配任何类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;Object&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</div><div class="line">        System.out.println(c.get(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">List&lt;String&gt; strList= <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">test(strList);<span class="comment">//此时会发生编译错误，java.util.List&lt;java.lang.String&gt;并不是java.util.List&lt;java.lang.Object&gt;的子类</span></div><div class="line"></div><div class="line"><span class="comment">//使用类型通配符修改如下</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</div><div class="line">        System.out.println(c.get(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">List&lt;String&gt; strList= <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">test(strList);</div></pre></td></tr></table></figure></p>
<h3 id="设定类型通配符的上限"><a href="#设定类型通配符的上限" class="headerlink" title="设定类型通配符的上限"></a>设定类型通配符的上限</h3><p>假设程序不希望这个List&lt;?&gt;是所有List泛型的父类，只希望它代表某一类泛型List的父类，可以写成&lt;? extends Class&gt;,其中(?)代表一个未知类型， 但是这个未知类型一定是Class的子类，因此可以把这个Class称为这个通配符的上线</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;? extends Object&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</div><div class="line">        System.out.println(c.get(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">List&lt;String&gt; strList= <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">test(strList);</div></pre></td></tr></table></figure>
<h3 id="设定类型形参的上限"><a href="#设定类型形参的上限" class="headerlink" title="设定类型形参的上限"></a>设定类型形参的上限</h3><p>Java泛型不仅允许使用通配符形参设定上线，也可以在定义类型形参设定上线<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;...&#125;</div><div class="line"></div><div class="line">Apple&lt;Integer&gt; ai = <span class="keyword">new</span> Apple&lt;&gt;();</div><div class="line">Apple&lt;Double&gt; ad = <span class="keyword">new</span> Apple&lt;&gt;();</div><div class="line"><span class="comment">//由于String不是Number的子类，所以会引发编译错误</span></div><div class="line">Apple&lt;String&gt; as = <span class="keyword">new</span> Apple&lt;&gt;();</div></pre></td></tr></table></figure></p>
<!--### 在方法签名中定义类型形参-->
<h3 id="设定类型通配符的下限"><a href="#设定类型通配符的下限" class="headerlink" title="设定类型通配符的下限"></a>设定类型通配符的下限</h3><p>Java允许设定通配符的下限:&lt;? super Type&gt;,这个通配符表示它必须是Type本身或者Type的父类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Collection&lt;? <span class="keyword">super</span> T&gt; dest, Collection&lt;T&gt; src)</span> </span>&#123;</div><div class="line">    T last = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">for</span> (T ele : src) &#123;</div><div class="line">        last = ele;</div><div class="line">        dest.add(ele);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> last;</div><div class="line">&#125;</div><div class="line"></div><div class="line">List&lt;Number&gt; ln = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">li.add(<span class="number">5</span>);</div><div class="line">Integer last = copy(ln, li);</div></pre></td></tr></table></figure></p>
<h3 id="泛型方法与方法重载"><a href="#泛型方法与方法重载" class="headerlink" title="泛型方法与方法重载"></a>泛型方法与方法重载</h3><p>假设有一个方法将Object数组的所有类型添加到一个Collection集合中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(Object[] a, Collection&lt;Object&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Object o : a) &#123;</div><div class="line">        c.add(o);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">String[] strArr = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;;</div><div class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//下面会报编译失败，因为java.util.List&lt;java.lang.String&gt;并不是java.util.List&lt;java.lang.Object&gt;的子类</span></div><div class="line">fromArrayToCollection(strArr, strList);</div><div class="line"></div><div class="line"><span class="comment">//如果将Colection&lt;Object&gt;改为Colection&lt;?&gt;是否可行？</span></div><div class="line"><span class="comment">//答：不可以，因为Java不允许把对象放进一个未知类型的集合</span></div></pre></td></tr></table></figure></p>
<p>为了解决这个问题，可以使用Java5提供的泛型方法,泛型方法格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[修饰符] &lt;T, S&gt; 返回值类型 方法名(形参列表)&#123;</div><div class="line">    <span class="comment">//方法体</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将上面方法修改为泛型方法</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(T[] a, Collection&lt;T&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (T o : a) &#123;</div><div class="line">        c.add(o);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如泛型方法在方法签名中声明类型形参，java也允许构造器签名中声明类型形参，这样就产生了泛型构造器。就可以根据参数类型”推断”类型形参的类型;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; Foo(T t)</div><div class="line">    &#123;</div><div class="line">        System.out.println(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//泛型T参数为String</span></div><div class="line"><span class="keyword">new</span> Foo(<span class="string">"dddddd"</span>);</div><div class="line"><span class="comment">//泛型T参数为Integer</span></div><div class="line"><span class="keyword">new</span> Foo(<span class="number">200</span>);</div><div class="line"><span class="comment">//显示指定泛型类型</span></div><div class="line"><span class="keyword">new</span> &lt;String&gt; Foo(<span class="string">"ddddd"</span>);</div><div class="line"><span class="comment">//下面代码出错</span></div><div class="line"><span class="keyword">new</span> &lt;String&gt; Foo(<span class="number">200</span>);</div></pre></td></tr></table></figure></p>
<!--### Java8改进的类型推断-->
<h3 id="擦除与转换"><a href="#擦除与转换" class="headerlink" title="擦除与转换"></a>擦除与转换</h3><p>当一个List<string>类型被转换成List类型，则改List对集合元素的类型检查变成了类型参数的上限(即Object)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    T size;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span> <span class="params">(T size)</span> </span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>.size = size;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSize</span><span class="params">()</span> </span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Apple&lt;Integer&gt; a = <span class="keyword">new</span> Apple&lt;&gt;();</div><div class="line">Integer as = a.getSize();</div><div class="line"><span class="comment">//把a对象赋给Apple变量，丢失尖括号的类型信息</span></div><div class="line">Apple b = a;</div><div class="line"><span class="comment">//b只知道Size的类型是Number</span></div><div class="line">Number size1 = b.getSize();</div><div class="line"><span class="comment">//下面引起编译错误</span></div><div class="line">Integer size2 = b.getSize();</div></pre></td></tr></table></figure></string></p>
<p>从逻辑上将，List<string>是List的子类，如果直接把List对象赋给List<string>应该会引起编译错误，实际上不会。对于泛型而言，可以直接把一个List对象赋给另一个list<string>对象，编译器仅仅提示”未经检查的转换”警告.但对list变量实际上引用的是List<integer>集合，所以试图把集合中的元素当成String类型取出时，将引发运行时异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">List&lt;integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">li.add(<span class="number">6</span>);</div><div class="line">List list = li;</div><div class="line"><span class="comment">//引发"未经检查的转换"警告，运行时正常</span></div><div class="line">List&lt;String&gt; ls = list;</div><div class="line"><span class="comment">//访问ls里的元素，引发运行时异常</span></div><div class="line">ls.get(<span class="number">0</span>);</div></pre></td></tr></table></figure></integer></string></string></string></p>
<h3 id="泛型与数组"><a href="#泛型与数组" class="headerlink" title="泛型与数组"></a>泛型与数组</h3><p>数组元素的类型不能包含类型变量或者类型形参，除非是无上限的类型通配符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面代码编译时有"[unchencked]"</span></div><div class="line">List&lt;String&gt; lsa = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</div><div class="line">Object[] oa = lsa;</div><div class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</div><div class="line">oa[<span class="number">1</span>] = li;</div><div class="line"><span class="comment">//下面代码引发ClassCastException异常</span></div><div class="line">String s = (String)lsa[<span class="number">1</span>].get(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">//Java允许创建无上限通配符泛型数组</span></div><div class="line">List&lt;?&gt; lsa = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</div><div class="line">Object[] oa = lsa;</div><div class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</div><div class="line">oa[<span class="number">1</span>] = li;</div><div class="line"><span class="comment">//下面代码依旧引发ClassCastException异常</span></div><div class="line">Object target = lsa[<span class="number">1</span>].get(<span class="number">0</span>);</div><div class="line"><span class="comment">//可修改为</span></div><div class="line"><span class="keyword">if</span> (target <span class="keyword">instanceof</span> String) &#123;</div><div class="line">    String s = (String) target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常机制可以使程序中的异常处理代码和正常的业务代码分离，保证代码优雅和提高程序的健壮性。Java的异常处理主要依赖于try、catch、finally、throw和throws五个关键字。</p>
<h3 id="Java异常类的继承体系"><a href="#Java异常类的继承体系" class="headerlink" title="Java异常类的继承体系"></a>Java异常类的继承体系</h3><p>Java提供了丰富的异常类，这些异常类有严格的继承关系。Java把所有的非正常情况分为两种：异常(Exception)和错误(Error)，他们都集成Throwable父类。Error错误一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这些错误不可捕获和修复，将导致程序终中断。<br>如下图<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-06-01.png" alt=""></p>
<h3 id="使用try…catch捕获异常"><a href="#使用try…catch捕获异常" class="headerlink" title="使用try…catch捕获异常"></a>使用try…catch捕获异常</h3><p>Java异常处理机制的语法结构:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">//业务实现代码</span></div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;<span class="keyword">catch</span> (ExceptionClass e) &#123;</div><div class="line">    <span class="comment">//异常信息处理1</span></div><div class="line">&#125;<span class="keyword">catch</span> (ExceptionClass e) &#123;</div><div class="line">    <span class="comment">//异常信息处理2</span></div><div class="line">&#125;<span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">//最终</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进行异常捕获时应该把所有父类异常的catch块排在子类异常的catch块后面，否则将出现编译错误。</p>
<h3 id="多异常捕获"><a href="#多异常捕获" class="headerlink" title="多异常捕获"></a>多异常捕获</h3><p>Java7开始一个catch可以捕获多种类型的异常。一个catch块捕获多个异常注意：</p>
<blockquote>
<ol>
<li>捕获多种类型的异常，多种异常类型之间用竖线(|)隔开</li>
<li>捕获多种类型的异常，异常变量有隐式final修饰，因此程序不能对异常变量重新赋值</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">int</span> a = Integer.parseInt(args[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">int</span> b = Integer.parseInt(args[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">int</span> c = a / b;</div><div class="line">&#125;<span class="keyword">catch</span> (IdexOutOfBoundsException | NumberFormatException ie) &#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="异常对象的常用方法"><a href="#异常对象的常用方法" class="headerlink" title="异常对象的常用方法"></a>异常对象的常用方法</h3><p>异常对象都包含了如下几个常用方法：</p>
<blockquote>
<ol>
<li>getMessage(): 返回该异常的详细描述字符串；</li>
<li>printStackTrace(): 将异常的跟踪栈信息输出到标准错误输出；</li>
<li>printStackTrace(PrintStream s): 将该异常的跟踪栈信息输出到指定输出流；</li>
<li>getStackTrace(): 返回异常的跟踪栈信息；</li>
</ol>
</blockquote>
<h3 id="finally块的作用"><a href="#finally块的作用" class="headerlink" title="finally块的作用"></a>finally块的作用</h3><p>不管try块中的代码是否出现了异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。</p>
<h3 id="自动关闭资源的try语句"><a href="#自动关闭资源的try语句" class="headerlink" title="自动关闭资源的try语句"></a>自动关闭资源的try语句</h3><p>当程序使用finally块关闭资源，程序显得异常臃肿。在Java7增强了try语句的功能-它允许try关键字后面紧跟一对圆括号，圆括号可以声明、初始化一个或多个资源，此处的资源指的是那些必须显示关闭的资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>(</div><div class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"AutoCloseTest.java"</span>));</div><div class="line">    PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"a.txt"</span>)))</div><div class="line">&#123;</div><div class="line">    br.readLine();</div><div class="line">    ps.println(<span class="string">"ccccc"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="异常处理的合理嵌套"><a href="#异常处理的合理嵌套" class="headerlink" title="异常处理的合理嵌套"></a>异常处理的合理嵌套</h3><p>在try…catch中再次嵌套try…catch称为异常处理的嵌套。异常处理嵌套的深度没有明确的限制，但通常没有必要使用超过两层的嵌套异常处理，层次太深的嵌套没有太大必要，而且导致程序的可读性降低。</p>
<h3 id="使用throws声明抛出异常"><a href="#使用throws声明抛出异常" class="headerlink" title="使用throws声明抛出异常"></a>使用throws声明抛出异常</h3><p>当前方法不知道如何处理这种异常，该异常应该由上一级调用者处理；如果main方法也不知道如何处理这种异常，也可以使用throws声明抛出异常，该异常交给JVM处理，JVM处理异常的方法是：将异常的跟踪栈打印并终止程序运行。throws声明抛出异常的语法格式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throws</span> ExceptionClass1, ExceptonClass2...</div></pre></td></tr></table></figure></p>
<p>一旦使用throws语句抛出该异常，程序就无须使用try…catch块捕获该异常了。但是调用者依旧需要使用try…catch块捕获异常或者再次声明异常抛出</p>
<h3 id="使用throw抛出异常"><a href="#使用throw抛出异常" class="headerlink" title="使用throw抛出异常"></a>使用throw抛出异常</h3><p>当程序出错时，系统会自动抛出异常，如果需要自行抛出异常，那么就要使用throw语句来完成。当Java接受无论是系统抛出异常还是自行抛出异常，Java运行时环境对于异常的处理没有任何差别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"a大于0"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>用户自定义异常都应该继承Exception基类，如果自定义Runtime异常，则应该继承RuntimeException基类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuctionException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></div><div class="line"><span class="class"></span>&#123;   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuctionException</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuctionException</span><span class="params">(String msg)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前面介绍异常处理方式有如下两种：</p>
<blockquote>
<ol>
<li>在出现异常的方法内捕获并处理异常，该方法的调用者将不能再次捕获该异常</li>
<li>该方法签名中声明抛出该异常，将该异常完全交给方法调用者处理</li>
</ol>
</blockquote>
<p>在实际应用中，单靠某个方法无法完全处理该异常，必须有几个方法协作才能完全处理。也就是说，在异常出现的当前方法中，程序只对异常进行部分处理，还有些处理要在该方法的调用者中才能完成，所以应该再次抛出异常，让该方法的调用者也能捕获到异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuctionTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bid</span><span class="params">(String bidPrice)</span><span class="keyword">throws</span> AuctionException </span>&#123;</div><div class="line">        <span class="keyword">double</span> d = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            d = Double.parseDouble(bidPrice);</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuctionException(<span class="string">"抛出"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    AuctionTest at = <span class="keyword">new</span> AuctionTest();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        at.bid(<span class="string">"df"</span>)</div><div class="line">    &#125;<span class="keyword">catch</span> (AuctionException e) &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="异常链和异常转译"><a href="#异常链和异常转译" class="headerlink" title="异常链和异常转译"></a>异常链和异常转译</h3><p>将底层的原始异常直接传给用户是一种不负责任的表现，通常做法是先捕获原始异常，然后抛出一个新的业务异常，这种处理方式称为异常转译。<br>这种把捕获一个异常然后接着抛出另一个异常，并把原始异常信息保存下来是一种典型的链式处理，也被称为”异常链”</p>
<h3 id="异常的处理规则"><a href="#异常的处理规则" class="headerlink" title="异常的处理规则"></a>异常的处理规则</h3><p>成功的异常处理应该先如下4个目标：</p>
<blockquote>
<ol>
<li>使程序代码混乱最小化</li>
<li>捕获并保留诊断信息</li>
<li>通知合适的人员</li>
<li>采用合适的方式结束异常活动</li>
</ol>
</blockquote>
<p>下面介绍达到这种效果的基本准则:</p>
<blockquote>
<ol>
<li>不要过度使用异常: 对于完全已知的错误，应该编写处理错误的代码，增强健壮性；只有对于外部的、未知的运行时错误才使用异常;</li>
<li>不要使用过于庞大的try块: 同一个try块后紧跟大量的catch块则需要分析他们之间的逻辑关系，增加编程的复杂度。正确做法是，将大块的try分割成多个可能出现异常的程序段落，并把它们放在单独的try块中，从而分别捕获并处理异常;</li>
<li>避免使用Catch All语句:所谓Catch All语句是指一种异常捕获模块，他可以处理程序发生的所有可能异常；</li>
<li>不要忽略捕获到的异常</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础(四)]]></title>
      <url>/2017/06/02/Java%E5%9F%BA%E7%A1%80-%E5%9B%9B/</url>
      <content type="html"><![CDATA[<h2 id="Java基础类库"><a href="#Java基础类库" class="headerlink" title="Java基础类库"></a>Java基础类库</h2><p>Oracle为Java提供了丰富的基础类库。Java提供了String、StringBuffer和StringBuilder来处理字符串，还提供了Date和Calendar来处理日期、时间,其中Date是一个已经过时的API，推荐使用Calendar来处理时间和日期。在JDK1.4后Java增加了对正则表达式的支持，新增Pattern和Matcher两个类，并让String类增加了正则表达式的支持。Java提供了国际化支持，使用Local对象封装一个国家、语言环境，在使用ResourceBundle根据Local加载语言资源包。</p>
<h3 id="Java程序的参数"><a href="#Java程序的参数" class="headerlink" title="Java程序的参数"></a>Java程序的参数</h3><p>Java程序的入口-main()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>1、public修饰符: Java类有JVM调用，为了让JVM可以自由调用main方法，所以使用pulibc修饰符<br>2、static修饰符: JVM调用主方法时，不会创建该主类的对象。JVM直接通过改了调用主方法。<br>3、void返回值: 主方法被JVM调用，该方法返回值将返回给JVM没有任何意义。<br>4、main方法的形参: main()方法由JVM调用，args形参有JVM赋值，可以在运行程序前的时候为args添加参数。</p>
<h3 id="程序运行过程中接收用户输入"><a href="#程序运行过程中接收用户输入" class="headerlink" title="程序运行过程中接收用户输入"></a>程序运行过程中接收用户输入</h3><p>Scanner可以获取用户的键盘输入，可以从文件、输入流、字符串中解析出基本类型值和字符串。Scanner提供了多个构造器，不同的构造器可以接受文件、输入流、字符串作为数据源。Scanner默认空白(空格、tab空白、回车)作为多个输入的分隔符。<br>Scanner主要提供了两个方法扫描输入:</p>
<ul>
<li>hasNetXxx():是否还有下一个输入项</li>
<li>nextXxx(): 获取下一个输入项</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line"><span class="comment">//只把回车作为分隔符</span></div><div class="line">sc.useDelimiter(<span class="string">"\n"</span>);</div><div class="line"><span class="keyword">while</span>(sc.hasNext()) &#123;</div><div class="line">    System.out.println(<span class="string">"键盘输入的内容:"</span> + sc.next());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="System类相关用法"><a href="#System类相关用法" class="headerlink" title="System类相关用法"></a>System类相关用法</h3><p>System类代表当前Java程序的运行平台，不能创建System对象，可以调用一些类变量和类方法。System类可以访问环境变量、系统属性的方法，还提供了加载文件和动态链接库的方法。System类提供两个获取系统时间的方法:currentTimeMillis()和nanoTime() 返回值都是long类型，距离1970年1月1日的时间差。两者区别:前者是毫秒单位，后者是纳秒单位。System类的in、out和err分别代表标准输入、标准输出和错误输出流，并提供setIn()、setOut()、setErr()改变系统的标准输入输出和错误输出流。System类还提供了一个idengtiyHashCode(Object x)方法，获取x的hashCode值，当x类重写hashCode()方法，依旧可以获取到根据该对象地址计算的hashCode值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取所有的环境变量</span></div><div class="line">Map&lt;String, String&gt; env = System.getenv();</div><div class="line"><span class="comment">//获取所有的系统属性</span></div><div class="line">Properties props = System.getProperties();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>System类提供通知垃圾回收的gc()方法和通知系统进行资源清理的runFinalization()方法。</p>
</blockquote>
<h3 id="Runtime类的相关用法"><a href="#Runtime类的相关用法" class="headerlink" title="Runtime类的相关用法"></a>Runtime类的相关用法</h3><p>Runtime类代表Java程序的运行时环境，每个Java程序都有一个与之对应的Runtime实例，应用程序不能创建Runtime实例，可以通过getRuntime()获取Rumtime对象。Runtime类可以访问JVM的相关信息，并且还可以直接单独启动一个进行运行操作系统的命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Runtime rt = Runtime.getRuntime();</div><div class="line"><span class="comment">//处理器数量</span></div><div class="line">rt.availableProcessors();</div><div class="line"><span class="comment">//空闲内存数</span></div><div class="line">rt.freeMemory();</div><div class="line"><span class="comment">//总内存数</span></div><div class="line">rt.totalMemory();</div><div class="line"><span class="comment">//可用最大内存数</span></div><div class="line">rt.maxMemory();</div><div class="line"><span class="comment">//执行操作系统命令</span></div><div class="line">rt.exec(<span class="string">"notepad.exe"</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>Runtime类也提供通知垃圾回收的gc()方法和通知系统进行资源清理的runFinalization()方法。并提供load(Stirng filename)和loadLibrary(String libname)方法加载文件和动态链接库。</p>
</blockquote>
<h3 id="Object与Objects类"><a href="#Object与Objects类" class="headerlink" title="Object与Objects类"></a>Object与Objects类</h3><p>Object是所有类、数组的父类。当一个类没有使用extends显示指定父类，则该类默认继承Object父类。Object提供如下几个常用方法:<br>&emsp; 1. &nbsp;boolean equals(Object obj):判断对象与该对象是否相等。<br>&emsp; 2. &nbsp;protected void finalize(): 当系统没有引用变量引用该对象是，垃圾回收期调用此方法来清理该对象的资源。<br>&emsp; 3. &nbsp;Class&lt;?&gt; getClass():返回该对象的运行时类。<br>&emsp; 4. &nbsp;int hashCode(): 返回改对象的hashCode()值。Object类的hashCode()方法是根据改对象的地址计算。<br>&emsp; 5. &nbsp;String toString(): 返回该对象的字符串表示。</p>
<p>除此之外还提供了wait()、notify()、notifyAll()方法，可以控制线程的暂停和运行。Java还提供了一个clone()方法，该方法被protected修饰，只能被子类重写或调用。自定义克隆步骤:<br>&emsp; 1. &nbsp;自定义类实现Cloneable接口；<br>&emsp; 2. &nbsp;自定义类实现clone()方法；<br>&emsp; 3. &nbsp;实现clone()方法是通过super.clone();调用Ojbect实现clone()方法得到该对象的副本;</p>
<p>Objects工具类，提供了一些工具方法操作对象。这些方法大多是”空指针”安全的。</p>
<h3 id="使用String、StringBuffer、StringBuilder类"><a href="#使用String、StringBuffer、StringBuilder类" class="headerlink" title="使用String、StringBuffer、StringBuilder类"></a>使用String、StringBuffer、StringBuilder类</h3><p>Java提供String、StringBuffer、StringBuilder封装字符串，并提供一系列方法操作字符串对象。<br>String类是不可变类。StringBuffer对象代表是可变的字符串。StringBuilder也代表字符串对象和StringBuffer基本相同，唯一不同的是StringBuffer是线程安全的，而StringBuilder没有实现线程安全功能。</p>
<blockquote>
<ol>
<li>String():创建一个包含0个字符串序列的String对象;</li>
<li>String(byte[] bytes, Charset charset):使用指定字符集将byte[]数组解码成一个新的字符串;</li>
<li>String(byte[] bytes, int offset, int length, Charset charset):使用指定字符集将byte[]数组从offset开始、长度为length的子数组解码成一个新的字符串;</li>
<li>String(byte[] bytes, String charsetName):使用指定字符集将byte[]数组解码成一个新的字符串;</li>
<li>String(byte[] values, int offset, int count):将指定字符数组从offset开始、长度为length的字符元素连缀成字符串。</li>
<li>String(String original):根据字符串常量创建一个String对象</li>
<li>String(StringBuffer buffer):根据StringBuffer对象创建响应的String对象</li>
<li>String(StringBuilder builder):根据StringBuilder对象创建响应的String对象</li>
<li>char charAt(int index):获取字符串指定位置的字符</li>
<li>int compareTo(String anotherString):比较两个字符串的大小</li>
<li>String concat(String str): 将该String对象与str连接在一起。</li>
<li>boolean contentEquals(StringBuffer sb):与sb进行比较，如果字符串相同返回true</li>
<li>static String copyValueOf(char[] data): 将字符数组连缀成字符串</li>
<li>boolean endsWith(String suffix): 该对象是否已suffix结尾</li>
<li>booean equals(Object anObject): 该字符串已指定对象比较是否相同</li>
<li>boolean equalsIgnoreCase(String str):与前一个方法相似，只是忽略大小写</li>
<li>byte[] getBytes(): 将该String对象转换成byte数组</li>
<li>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin): 将字符串从srcBein开始到srcEnd结束的字符复制到dst字符数组中，其中dstBegin为目标字符数组的起始赋值位置。</li>
<li>int indexOf(int ch):找出ch字符第一次出现的下标</li>
<li>int indexOf(int ch, int fromIndex):找出ch字符在该字符串中从fromIndex开始第一次出现的下标</li>
<li>int indexOf(String str):找出str字符串在该字符串第一次出现的下标</li>
<li>int indexOf(String str, int fromIndex):找出str字符串在该字符串中从fromIndex开始第一次出现的下标</li>
<li>int lastIndex(int ch):找出ch字符最后一次出现的下标</li>
<li>int lastIndex(int ch, int fromIndex):找出ch字符在该字符串中从fromIndex开始最后一次出现的下标</li>
<li>int lastIndex(String str):找出str字符串在该字符串最后一次出现的下标</li>
<li>int lastIndex(String str, int fromIndex):找出str字符串在该字符串中从fromIndex开始最后一次出现的下标</li>
<li>int length(): 返回当前字符串的长度</li>
<li>String replace(char oldChar, char newChar): 将字符串中的第一个oldChar替换成newChar</li>
<li>boolean startsWith(String prefix): 该String对象是否以prefix开始</li>
<li>boolean startsWith(String prefix, int toffset): 该String对象从toffset位置算起是否已prefix开始</li>
<li>String substring(int beginIndex):获取从beginIndex位置开始到结束的子字符串</li>
<li>String substring(index beginIndex, int endIndex): 获取从beginIndex到endIndex位置的子字符串</li>
<li>char[] toCharArray():将String对象转换成char数组</li>
<li>String toLowerCase():将字符串转成小写</li>
<li>String toUpperCase():将字符串转成大写</li>
</ol>
</blockquote>
<h3 id="使用Math类进行数学计算"><a href="#使用Math类进行数学计算" class="headerlink" title="使用Math类进行数学计算"></a>使用Math类进行数学计算</h3><p>Java对于复杂的数学运算提供了Math工具类来完成这些运算。具体方法可查看API.</p>
<h3 id="使用BigDecimal保存精确浮点数"><a href="#使用BigDecimal保存精确浮点数" class="headerlink" title="使用BigDecimal保存精确浮点数"></a>使用BigDecimal保存精确浮点数</h3><p>float、double两种基本浮点类型容易引起精度丢失。为了能精确表示，计算浮点数，Java提供BigDecimal类。BigDecimal提供了加、减、乘、除基本运算。不建议使用BigDecimal(double val)构造器，会产生一定的不可预知性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//0.05 + 0.01 = 0.0600000000000005</span></div><div class="line">System.out.println(<span class="string">"0.05 + 0.01 = "</span> + (<span class="number">0.05</span> + <span class="number">0.01</span>));</div><div class="line">BigDecimal f1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.05"</span>);</div><div class="line">BigDecimal f2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.01"</span>);</div><div class="line"><span class="comment">//0.05 + 0.01 = 0.06</span></div><div class="line">System.out.println(<span class="string">"0.05 + 0.01 = "</span> + f1.add(f2));</div></pre></td></tr></table></figure></p>
<h3 id="使用Random类生成各种伪随机数"><a href="#使用Random类生成各种伪随机数" class="headerlink" title="使用Random类生成各种伪随机数"></a>使用Random类生成各种伪随机数</h3><p>Random类专门生成伪随机数,他有两个构造器一个构造器默认使用当前时间，另一个构造器显示传入一个long型的种子。如果种子相同，对于同样顺序的调用方法，会产生相同的数字序列。ThreadLocalRandom类是Java7新增的类，用于在并发环境下减少多线程资源竞争，保证线程安全性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Random rand = <span class="keyword">new</span> Random();</div><div class="line">rand.nextBoolean();</div><div class="line">rand.nextDouble();</div><div class="line">rand.nextInt();</div></pre></td></tr></table></figure></p>
<h3 id="Date、Calendar的用法及之间的联系"><a href="#Date、Calendar的用法及之间的联系" class="headerlink" title="Date、Calendar的用法及之间的联系"></a>Date、Calendar的用法及之间的联系</h3><p>Java提供了Date和Calendar用于处理日期、时间的类，包括创建日期、事件对象、获取系统当前日期、时间等操作。Date无法实现国际化。<br>Date类处理日期和时间，Date对象既包含日期也包含时间。Date提供6个构造器，其中4个已过期，剩下两个构造器分别是: </p>
<ul>
<li>Date(): 生成一个当前日期时间的Date对象。该构造器在底层调用System.currentTimeMillis()获得long整数作为日期参数。</li>
<li>Date(long date):根据指定的long生成一个Date对象，参数表示创建的Date对象距离1970年的时间差，以毫秒作为计时单位。</li>
</ul>
<p>如果需要对日期、时间进行加减运算或获取指定时间的年月日时分秒信息，可使用Calendar工具类。<br>Calendar是一个抽象类，它用于表示日历。Java本身提供了一个GregorianCalendar类，代表公历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Calendar calendar = Calendar.getInstance();</div><div class="line"><span class="comment">//从Calendar对象中获取Date对象</span></div><div class="line">Date date = calendar.getTime();</div><div class="line"></div><div class="line">Calendar calendar = Calendar.getInstance();</div><div class="line"><span class="comment">//从Calendar对象中设置Date</span></div><div class="line">calendar.setTime(date);</div></pre></td></tr></table></figure></p>
<p>Calendar类提供了大量访问、修改日期时间的方法，常用方法如下:</p>
<ul>
<li>void add(int field, int amount): 根据日历规则，为给定日历字段添加或减去指定的时间量</li>
<li>int get(int field): 返回指定日历字段的值</li>
<li>int getActualMaximum(int field): 返回指定日历字段可能拥有最大值</li>
<li>int getActualMinimum(int field): 返回指定日历字段可能拥有最小值</li>
<li>void roll(int field, int amount): 与add()方法类似，区别不会向上一个字段进位</li>
<li>void set(int field, int value): 将给定日历字段设置为定制</li>
<li>void set(int year, int month, int date): 设置Calendar对象的年、月、日</li>
<li>void set(int year, int month, int date, int hourOfDay, int minute, int second): 设置Calendar对象的年、月、日、时、分、秒</li>
</ul>
<h3 id="通过String类使用正则表达式"><a href="#通过String类使用正则表达式" class="headerlink" title="通过String类使用正则表达式"></a>通过String类使用正则表达式</h3><p>正则表达式是一个强大的字符串处理工具，可以对字符串进行查找、提取、分割、替换等操作。Stirng类提供如下几个特殊方法：</p>
<ul>
<li>boolean matches(String regex): 判断字符串是否匹配指定的正则表达式</li>
<li>String replaceAll(String regex, String replacement): 将匹配regex的子串替换成replacement</li>
<li>String replaceFirst(String regex, String replacement): 将字符串第一个匹配regex的子串替换成replacement</li>
<li>String[] split(String regex): 以regex作为分隔符，分割成多个子串</li>
</ul>
<p>使用正则表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pattern p = Pattern.compile(<span class="string">"a*b"</span>);</div><div class="line">Matcher m = p.matcher(<span class="string">"aaaaaab"</span>);</div><div class="line"><span class="keyword">boolean</span> b = m.matches();</div></pre></td></tr></table></figure></p>
<p>Matcher类提供如下常用的方法：</p>
<ul>
<li>find(): 返回目标字符串中是否包含与Pattern匹配的字符串</li>
<li>group(): 返回上一次与Pattern匹配的子串</li>
<li>start(): 返回上一次与Pattern匹配的子串在目标字符串的开始位置</li>
<li>end(): 返回上一次与Pattern匹配的子串在目标字符串的结束位置+1</li>
<li>lookingAt(): 返回目标字符串前面部分与Pattern是否匹配</li>
<li>matches(): 返回整个目标字符串与Pattern是否匹配</li>
<li>reseet():将现有的Matcher对象应用于一个新的字符序列。</li>
</ul>
<h3 id="使用NumberFormat格式化数字"><a href="#使用NumberFormat格式化数字" class="headerlink" title="使用NumberFormat格式化数字"></a>使用NumberFormat格式化数字</h3><p>NumberFormat是Format抽象类的子类，可以实现数值的格式化。可以将数值与字符串互相转化。NumberFormat是抽象类可以通过如下几个类方法获取NumberFormat对象：</p>
<ul>
<li>getCurrencyInstance(): 返回默认Locale的货币格式器，也可以传入指定的Locale</li>
<li>getIntegerInstance(): 返回默认Locale整数格式器，也可以传入指定的Locale</li>
<li>getNumberInstance(): 返回默认Locale数值格式器，也可以传入指定的Locale</li>
<li>getPercentInstance(): 返回默认Locale百分数格式器，也可以传入指定的Locale</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NumberFormat format = NumberFormat.getNumberInstance(Locale.CHINA);</div><div class="line">format.format(<span class="number">12345.45</span>);</div></pre></td></tr></table></figure>
<h3 id="使用DateFormat、SimpleDateFormat格式化日期"><a href="#使用DateFormat、SimpleDateFormat格式化日期" class="headerlink" title="使用DateFormat、SimpleDateFormat格式化日期"></a>使用DateFormat、SimpleDateFormat格式化日期</h3><p>DateFormat是Format抽象类的子类，可以实现日期的格式化。可以将日期与字符串互相转化。DateFormat是抽象类可以通过如下几个类方法获取DateFormat对象：</p>
<ul>
<li>getDateInstance(): 返回一个日期格式器，格式化后字符串只有日期，没有时间，可传参指定日期样式和Locale</li>
<li>getTimeInstance():返回一个时间格式器，格式化后只有时间没有日期，可传参指定时间样式和Locale</li>
<li>getDateTimeInstance(): 返回一个日期、时间格式器，格式化后既有日期也有时间，可传参指定日期样式、时间样式和Locale</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//指定日期样式、时间样式参数，是DateFormat的4个静态常量：FULL、LONG、MEDIUM、SHORT</span></div><div class="line">DateFormat format = DateFormat.getDateInstance(FULL);</div><div class="line">Date date = <span class="keyword">new</span> Date();</div><div class="line">format.format(date);</div></pre></td></tr></table></figure>
<p>DateFormat的parse()方法可以把字符串转成Date,但字符串必须符合特定的格式，为了更好的格式化日期、解析日期字符串Java提供了SimpleDateFormat类。<br>SimpleDateFormat是DateFormat子类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Date d = <span class="keyword">new</span> Date();</div><div class="line">SimpleDateFormat sdfl = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"Gyyyy年中第D天"</span>);</div><div class="line">String dateStr = sdfl.format(d);</div><div class="line"></div><div class="line">String str = <span class="string">"14###三月##21"</span>;</div><div class="line">SimpleDateFormat sdf2 = new SimpleDateFormat(y###MM##dd);</div><div class="line">sdf2.parse(str);</div></pre></td></tr></table></figure></p>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>Java集合可以存储数量不等的对象，并可以实现常用的数据结构，如栈、队列等。除此之外，Java的集合还可以保存有映射关系的关联数组。Java集合大致分为Set、List、Queue和Map四种体系，Set代表无序不可重复、List代表有序重复；而Map代表有映射关系的集合；Java5增加Queue体系的集合，代表队列集合。对于Set、List、Queue和Map四种集合，最常用的实现类分别是：HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList和HashMap、TreeMap等实现类；<br>集合和数组不一样，数组元素既可以保存基本类型的值也可以是对象，但长度固定下来不可变化。而集合只能保存对象，长度可以变化。<br>Java集合主要有两个接口派生而来:Collection和Map，Collection和Map是Java集合框架的根接口。<br>下面展示Colleciton和Map的接口、子接口及其实现类的继承树：<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-05-01.png" alt=""><br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-05-02.png" alt=""></p>
<p>Collection接口是List、Set和Queue接口的父接口。Collection接口定义了如下操作集合元素的方法：</p>
<ul>
<li>boolean add(Object o):像集合中添加一个元素，添加成功返回true</li>
<li>boolean addAll(Collection c):把集合c中的元素添加到指定集合中</li>
<li>void clear(): 清除集合中的所有元素</li>
<li>boolean contains(Object o):该对象是否包含指定元素</li>
<li>boolean containsAll(Collection c):返回集合对象是否包含集合c中所有元素</li>
<li>boolean isEmpty():集合是否为空</li>
<li>Iterator iterator():返回Iterator对象，用于遍历集合元素</li>
<li>boolean remove(Object o):删除集合中指定元素o,如果集合包含多个元素o，只删除第一个</li>
<li>boolean removeAll(Collection c): 在集合中删除集合c中所有元素</li>
<li>boolean retainAll(Collection c): 在集合中删除集合c不包含的元素</li>
<li>int size():返回集合元素个数</li>
<li>Object[] toArray(): 把集合转化成一个数组</li>
</ul>
<h3 id="使用Lambda表达式遍历集合"><a href="#使用Lambda表达式遍历集合" class="headerlink" title="使用Lambda表达式遍历集合"></a>使用Lambda表达式遍历集合</h3><p>Java8为Iterable接口新增forEach(Consumer action)默认方法，该方法参数是一个函数式接口，而Iterable接口是Collection接口的父接口，因此可以直接调用。 使用forEach遍历集合时，程序集合元素传给Consumer的accept(T t)方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Collection books = <span class="keyword">new</span> HashSeet();</div><div class="line">books.add(<span class="string">"轻量级Java EE企业应用实战"</span>);</div><div class="line">books.add(<span class="string">"疯狂Java讲义"</span>);</div><div class="line">books.add(<span class="string">"疯狂Android讲义"</span>);</div><div class="line">books.forEach(obj -&gt; System.out.println(<span class="string">"迭代集合元素:"</span> + obj));</div></pre></td></tr></table></figure></p>
<h3 id="使用Predicate操作集合"><a href="#使用Predicate操作集合" class="headerlink" title="使用Predicate操作集合"></a>使用Predicate操作集合</h3><p>Java8新增Predicate来操作集合，Java8为Collection新增一个removeIf(Predicate filter)方法，该方法会批量删除filter条件的所有元素。该方法需要一个Predicate(谓词)作为参数，Predicate是一个函数式接口，因此可以使用Lambda表达式作为参数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//移除所有字符串长度小于10的</span></div><div class="line">books.removeIf(ele -&gt; ((String)ele).length() &lt; <span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<h3 id="使用Iterator和foreach循环遍历Collection集合"><a href="#使用Iterator和foreach循环遍历Collection集合" class="headerlink" title="使用Iterator和foreach循环遍历Collection集合"></a>使用Iterator和foreach循环遍历Collection集合</h3><p>Iteraotr接口是Java集合框架的主要成员，Iterator主要用于遍历Collection集合中的元素，Iterator也被称为迭代器。</p>
<ul>
<li>boolean hasNext():如果迭代集合元素没有遍历完，返回true</li>
<li>Object next(): 返回集合里下一个元素</li>
<li>void remove():删除集合里上一次next方法返回的元素</li>
<li>void forEachRemaining(Consumer action): Java8添加新方法，可以使用Lambda遍历集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Iterator it = books.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext() &#123;</div><div class="line">    String book = it.next();</div><div class="line">    <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Java讲义"</span>)) &#123;</div><div class="line">        <span class="comment">//从集合中删除上一次next()方法返回的元素</span></div><div class="line">        it.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用Lambda表达式遍历Iterator</span></div><div class="line">it.forEachRemaining(obj -&gt; System.out.println(<span class="string">"迭代集合元素："</span> + obj));</div><div class="line"></div><div class="line"><span class="comment">//使用foreach循环遍历集合</span></div><div class="line"><span class="keyword">for</span> (Object obj : books) &#123;</div><div class="line">    String book = (String)obj;</div><div class="line">    <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Java讲义"</span>)) &#123;</div><div class="line">        <span class="comment">//下面代码会引发ConcurrentModificationException，不建议在循环中使用集合本身删除元素</span></div><div class="line">        books.remove(book);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对集合使用Stream进行流式编程"><a href="#对集合使用Stream进行流式编程" class="headerlink" title="对集合使用Stream进行流式编程"></a>对集合使用Stream进行流式编程</h3><p>Java8新增Stream、IntStream、LongStream、DoubleStream等流式API,Stream是一个通用流式接口，IntStream、LongStream、DoubleStream则代表元素为int, long, double的流。<br>使用步骤:</p>
<ul>
<li>使用Stream或XxxStream的builder()类方法创建对应的builder;</li>
<li>重复调用Builder的add()方法添加元素</li>
<li>调用Builder的build()方法获得对应的Stream</li>
<li>调用Stream的聚集方法</li>
</ul>
<p>例如如下程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">IntStream is = IntStream.builder()</div><div class="line">        .add(<span class="number">20</span>)</div><div class="line">        .add(<span class="number">13</span>)</div><div class="line">        .add(-<span class="number">2</span>)</div><div class="line">        .add(<span class="number">18</span>).build();</div><div class="line"><span class="comment">//下面调用聚集方法每次只能执行一行</span></div><div class="line">is.max().getAsInt();</div><div class="line">is.min().getAsInt();</div><div class="line">is.sum();</div><div class="line">....</div><div class="line"><span class="comment">//中间方法</span></div><div class="line">IntStream newIs = is.map(ele-&gt;ele * <span class="number">2</span> + <span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>Stream提供大量方法进行聚集操作，这些方法既可以是”中间的”，也可以是”末端的”。</p>
<ul>
<li>中间方法: 中间操作允许流保持打开状态，并允许直接调用后续方法。上面map()方法就是中间方法。中间方法返回值是另外一个流</li>
<li>末端方法: 末端方法是对流的最终操作。当使用末端方法后，该流就会”消耗”且不可再用.</li>
<li>有状态的方法: 这种方法会给流添加一些新的属性，比如元素的唯一性、元素的最大数量等</li>
<li>短路方法: 短路方法可以尽早结束对流的操作，不必检查所有的元素。</li>
</ul>
<h3 id="EnumSet的用法"><a href="#EnumSet的用法" class="headerlink" title="EnumSet的用法"></a>EnumSet的用法</h3><p>EnumSet是一个转为枚举类设计的集合类，EnumSet所有的元素必须是指定的枚举类型的枚举值。EnumSet的集合元素是有序的。EnumSet不允许添加null元素。</p>
<h3 id="HashSet、LinkedHashSet用法"><a href="#HashSet、LinkedHashSet用法" class="headerlink" title="HashSet、LinkedHashSet用法"></a>HashSet、LinkedHashSet用法</h3><p>HashSet按照Hash算法存储集合，具有很好的存取和查找性能。HashSet具有以下特点:</p>
<ul>
<li>不能保证元素的排列顺序，书序可能与添加顺序不同，顺序也可能发生变化</li>
<li>HashSet不是同步的，如果多个线程同时访问一个HashSet,假设有两个或两个以上线程同时修改集合是，则必须通过代码保证其同步</li>
<li>集合元素值可以是nul</li>
</ul>
<p>HashSet集合存入一个元素时，会调用HashCode()方法得到该对象的hashCode值，然后根据hashCode决定该对象的存储位置。如果两个元素通过equals()方法比较返回true,但他们的hashCode()返回值不相等，HashSet将会把他们存放在不同的位置上，也可以说是添加成功。<br>也就是说HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法返回值也相等。</p>
<blockquote>
<p>注意：如果需要将某个类的对象保存到HashSet集合中，重写这个类的equals()和hashCode()方法时，应尽量保证，equals()返回true时，他们的hashCode()也相等</p>
</blockquote>
<p>LinkedHashSet类是HashSet的子类，LinkedHashSet集合也是根据hashCode值决定元素的存储位置，但它同时维护添加顺序，性能略低于HashSet,但在迭代访问Set的全部元素将有很好的性能，他是以链表来维护内部顺序。</p>
<h3 id="TreeSet的用法"><a href="#TreeSet的用法" class="headerlink" title="TreeSet的用法"></a>TreeSet的用法</h3><p>TreeSet是SortedSet接口的实现类，TreeSet确保集合元素处于排序状态。TreeSet并不是根据插入顺序排序，而是根据元素的实际值大小排序。 与HashSet相比，TreeSet还提供了几个额外的方法:</p>
<ul>
<li>Comparator comparator(): 如果TreeSet采用定制排序，则返回定制排序的Comparator,如果采用自然排序，则返回null</li>
<li>Object first(): 返回集合中第一个元素</li>
<li>Object last(): 返回集合中最后一个元素</li>
<li>Object lower(Object e): 返回集合中小于指定元素的所有元素</li>
<li>Object higher(Object e): 返回集合中大于指定元素的所有元素</li>
<li>SortedSet subSet(Object fromElement, Object toElement): 返回此Set的子集合，范围是fromElement到toElement</li>
<li>SortedSet headSet(Object toElement):返回此Set的子集合，由小于toElement的元素组成</li>
<li>SortedSet tailSet(Object fromElement):返回此Set的子集合，由大于fromElement的元素组成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TreeSet nums = <span class="keyword">new</span> TreeSet();</div><div class="line">nums.add(<span class="number">5</span>);</div><div class="line">nums.add(<span class="number">2</span>);</div><div class="line">nums.add(<span class="number">10</span>);</div><div class="line">nums.add(-<span class="number">9</span>);</div><div class="line">nums.frist();<span class="comment">//-9</span></div><div class="line">nums.last();<span class="comment">//10</span></div><div class="line">nums.headSet(<span class="number">5</span>)<span class="comment">//[-9, 2]</span></div></pre></td></tr></table></figure>
<p>1、自然排序:TreeSet会调用元素的compareTo(Object obj)方法比较元素之间的大小，然后将集合元素按照升序排列， 这就是自然排序。Java提供了Comparable接口，该接口定义了compareTo(Object obj)方法。<code>obj1.compareTo(obj2)</code> 该方法返回0则两个对象相等，返回正整数obj1大于obj2，返回负整数则obj1小于obj2。Java的一些常用类已经实现Comparable接口,如 BigDecimal、Character、Boolean、String、Date、Time等。<font color="red">如果把一个对象添加到TreeSet时，该对象必须实现Comparable接口，否则会抛出异常,并且尽量添加同一种类型的对象</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">TreeSet ts = <span class="keyword">new</span> TreeSet();</div><div class="line"><span class="comment">//Err类没有实现Comparable接口，在添加第二个对象进行比较时抛出异常。</span></div><div class="line">ts.add(<span class="keyword">new</span> Err());</div><div class="line">ts.add(<span class="keyword">new</span> Err());</div><div class="line"></div><div class="line">TreeSet ts2 = <span class="keyword">new</span> TreeSet();</div><div class="line"><span class="comment">//添加不同类型的对象，当添加Date到TreeSet时，调用CompareTo方法，抛出异常</span></div><div class="line">ts2.add(<span class="keyword">new</span> String(<span class="string">"abc"</span>));</div><div class="line">ts2.add(<span class="keyword">new</span> Date());</div></pre></td></tr></table></figure></p>
<p>2、定制排序:可以通过Comparator接口，该接口包含一个int compare(T o1, T 02)方法，由于Comparator是一个函数式接口，可以使用Lambda表达式来代替。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TreeSet ts = <span class="keyword">new</span> TreeSet((o1, o2) -&gt; &#123;</div><div class="line">    <span class="keyword">return</span> o1 &gt; o2 ? -<span class="number">1</span> : o1 &lt; o2 ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="List集合的常规用法"><a href="#List集合的常规用法" class="headerlink" title="List集合的常规用法"></a>List集合的常规用法</h3><p>List集合作为Collection的子接口，可以使用Collection的全部方法。List集合增加了一写根据索引来操作集合的方法：</p>
<ul>
<li>void add(int index, Object element): 将元素插入到List集合index处</li>
<li>boolean addAll(int index, Collection c):将集合c所有元素插入到List集合index处</li>
<li>Object get(int index):返回集合index索引的元素</li>
<li>int indexOf(Object o):返回元素o的索引</li>
<li>int lastIndexOf(Ojbect o):返回对象o在List集合中最后一次出现的索引</li>
<li>Object remove(int index): 移除索引为index的元素</li>
<li>Object set(int index, object element):将index索引处的元素替换成element对象，返回被替换的元素</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex(包含)到toIndex(不包含)处所有集合元素组成的子元素</li>
<li>void replaceAll(UnaryOperator operator):根据operator指定的计算规则重新设置List集合的所有元素</li>
<li>void sort(Comparator c):根据Comparator参数对List集合的元素进行排序</li>
</ul>
<p>与Set只提供Iterator()方法不同，List还额外提供listIterator()方法，该方法返回ListIterator对象，ListIterator继承Iterator接口，提供了专门操作List的方法，新增了如下方法：</p>
<ul>
<li>boolean hasPrevious():返回该迭代器关联的集合是否还有上一个元素</li>
<li>Object previous():返回该迭代器的上一个元素</li>
<li>void add(Object o):指定位置添加一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">List bookList = <span class="keyword">new</span> ArrayList();</div><div class="line">bookList.add(<span class="string">"疯狂Java讲义"</span>);</div><div class="line">bookList.add(<span class="string">"疯狂iOS讲义"</span>);</div><div class="line">bookList.add(<span class="string">"轻量级JavaEE企业应用实战"</span>);</div><div class="line">ListIterator lit = bookList.listIterator();</div><div class="line"><span class="keyword">while</span>(lit.hasNext()) &#123;</div><div class="line">    System.out.println(lit.next());</div><div class="line">&#125;</div><div class="line"><span class="comment">// ------反向迭代----------</span></div><div class="line"><span class="keyword">while</span>(lit.hasPrevious()) &#123;</div><div class="line">    System.out.println(lit.previous());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a>ArrayList和Vector</h3><p>ArrayList和Vector都是基于数组实现的List类。封装了一个动态的、允许再分配的Object[]数组。ArrayList和Vector用法基本相同，ArrayList是线程不安全的。多个线程访问同一个ArrayList集合，如果有超过一个线程修改，则要手动保证集合的同步性；</p>
<h3 id="Queue接口与Deque接口"><a href="#Queue接口与Deque接口" class="headerlink" title="Queue接口与Deque接口"></a>Queue接口与Deque接口</h3><p>Queue用于模拟队列数据结构，队列指”先进先出”。Queue接口有一个PriorityQueue实现类。 Queue接口提供了如下方法：</p>
<ul>
<li>void add(Object e):将指定元素加入队列尾部</li>
<li>Object element():获取队列头部元素，但不删除该元素</li>
<li>boolean offer(Object e): 将指定元素加入队列尾部。当使用有容量限制的队列，此方法通常比add方法更好</li>
<li>Object peek():获取队列头部元素，但不删除该元素，如果队列为空，返回null</li>
<li>Object poll():获取队列头部元素，并删除该元素，如果队列为空，返回null</li>
<li>Object remove():获取队列头部元素，并删除该元素</li>
</ul>
<p>Deque接口是Queue接口的子接口，Deque代表一个”双端队列”，双端队列可以同时从两端添加、删除元素。Deque接口提供一个典型实现类：ArrayDeque</p>
<ul>
<li>void addFirst(Object e):指定元素插入双端队列开头</li>
<li>void addLast(Object e):指定元素插入双端队列末尾</li>
<li>Iterator descendingIterator():返回双端队列的迭代器，该迭代器以逆向顺序迭代</li>
<li>Object getFirst():获取但不删除第一个元素</li>
<li>Object getLast():获取但不删除最后一个元素</li>
<li>boolean offerFirst(Object e):将指定元素插入开头</li>
<li>boolean offerLast(Object e):将指定元素插入末尾</li>
<li>Object peekFirst():获取不删除第一个元素，队列为空返回null</li>
<li>Object peekLast():获取不删除最后一个元素，队列为空返回null</li>
<li>Object pollFirst():获取并删除第一个元素，队列为空返回null</li>
<li>Object pollLast():获取并删除最后一个元素，队列为空返回null</li>
<li>Object pop():pop出栈顶元素</li>
<li>Object push(Object e):讲一个元素push进双端队列的栈顶</li>
<li>Object removeFirst():获取并删除第一个元素</li>
<li>Object removeFirstOccurrence(Object o): 删除双端队列第一次出现的元素o</li>
<li>Object removeLast():获取并删除最后一个元素</li>
<li>Object removeLastOccurrence(Object o): 删除双端队列最后一次出现的元素o</li>
</ul>
<h3 id="PriorityQueue的用法"><a href="#PriorityQueue的用法" class="headerlink" title="PriorityQueue的用法"></a>PriorityQueue的用法</h3><p>PriorityQueue是一个比较标准的队列实现类，PriorityQueue队列的顺序不是加入顺序，是排序后的顺序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PriorityQueue pq = <span class="keyword">new</span> PriorityQueue();</div><div class="line">pq.offer(<span class="number">6</span>);</div><div class="line">pq.offer(-<span class="number">3</span>);</div><div class="line">pq.offer(<span class="number">20</span>;</div><div class="line">pq.offer(<span class="number">18</span>);</div><div class="line">System.out.println(pq);<span class="comment">//[-3, 6, 18, 20]</span></div></pre></td></tr></table></figure></p>
<h3 id="ArrayDeque的用法"><a href="#ArrayDeque的用法" class="headerlink" title="ArrayDeque的用法"></a>ArrayDeque的用法</h3><p>ArrayDeque既可以作为栈使用，也可以作为队列使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当做栈使用</span></div><div class="line">ArrayDeque stack = <span class="keyword">new</span> ArrayDeque();</div><div class="line">stack.push(<span class="string">"疯狂Java讲义"</span>);</div><div class="line">stack.push(<span class="string">"疯狂Android讲义"</span>);</div><div class="line">stack.push(<span class="string">"疯狂iOS讲义"</span>);</div><div class="line">stack.pop();</div><div class="line"><span class="comment">//当做队列使用</span></div><div class="line">ArrayDeque stack2 = <span class="keyword">new</span> ArrayDeque();</div><div class="line">stack2.offer(<span class="string">"疯狂Java讲义"</span>);</div><div class="line">stack2.offer(<span class="string">"疯狂Android讲义"</span>);</div><div class="line">stack2.offer(<span class="string">"疯狂iOS讲义"</span>);</div><div class="line">stack2.poll();</div></pre></td></tr></table></figure></p>
<h3 id="LinkedList集合的用法"><a href="#LinkedList集合的用法" class="headerlink" title="LinkedList集合的用法"></a>LinkedList集合的用法</h3><p>LinkedList类是List的实现类，并且还实现了Deque接口，由此可见LinkedList是一个功能强大的集合类。LinkedList内部是以链表的形式保存集合元素，随机访问性能比ArrayList、ArrayDeque差，但在插入删除性能比较出色。</p>
<h3 id="Map的概念和常规用法"><a href="#Map的概念和常规用法" class="headerlink" title="Map的概念和常规用法"></a>Map的概念和常规用法</h3><p>Map用于保存具有映射关系的数据，Map集合保存两组值，一组key和一组value,key和value可以是任何引用类型数据，Map的key不允许重复。从Map中获取元素则需要通过该元素的key索引获取，因此Map有时也被称为字典。Map接口中常用的方法：</p>
<ul>
<li>void clear():删除Map对象所有元素</li>
<li>boolean containsKey(Object key):查询Map中是否包含指定的key</li>
<li>boolean containsValue(Object value):查询Map中是否包含指定的value</li>
<li>Set entrySet(): 返回Map中包含Key-value对所组成的Set集合，每个集合都是Map.Entry对象</li>
<li>Object get(Object key):根据key获取到value</li>
<li>boolean isEmpty():Map是否为空</li>
<li>Set keySet():Map中所有key组成的Set集合</li>
<li>Object put(Object key, Object value):添加指定的key-value,如果存在与key相等的key-value 则会覆盖</li>
<li>void putAll(Map m):将指定Map中的key-value对覆盖原来的key-value中。</li>
<li>Object remove(Object key):删除指定key所对应的key-value,并返回value</li>
<li>boolean remove(Object key, Object value): Java8新增方法，删除指定key、value</li>
<li>int size():返回Map里Key-value的个数</li>
<li>Collection values():返回Map里所有value组成的Collection;</li>
</ul>
<p>Map接口提供大量实现类，如HashMap和Hashtable等、HashMap的子类LinkedhashMap,还有SortedMap子接口及其该实现类TreeMap,以及WeakHashMap、IdentityHashMap等</p>
<h3 id="HashMap和Hashtable"><a href="#HashMap和Hashtable" class="headerlink" title="HashMap和Hashtable"></a>HashMap和Hashtable</h3><p>HashMap和Hashtable的关系类似于ArrayList和Vector的关系，Hashtable是一个古老的Map实现类。Hashtable是一个线程安全的Map实现，但HashMap是线程不安全的实现。Hashtable不允许null作为key或者value,但是HashMap可以。<br>和HashSet集合一样都不能保证key-value所在的顺序。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是HashMap的子类，LinkedHashMap也使用双向链表维护key-value的书序</p>
<h3 id="SortedMap接口和TreeMap的用法"><a href="#SortedMap接口和TreeMap的用法" class="headerlink" title="SortedMap接口和TreeMap的用法"></a>SortedMap接口和TreeMap的用法</h3><p>SortedMap是Map的子接口，TreeMap是SortedMap的实现类。TreeMap存储key-value时，需要根据key对节点进行排序。TreeMap也有两种排序方式:</p>
<ul>
<li>自然排序：TreeMap的key必须实现Comparable接口，而且所有的key应该是同一个类的对象</li>
<li>定制排序：创建TreeMap是传入一个Comparator对象，该对象负责对TreeMap的所有key进行排序。</li>
</ul>
<h3 id="Properties类读写属性文件"><a href="#Properties类读写属性文件" class="headerlink" title="Properties类读写属性文件"></a>Properties类读写属性文件</h3><p>Properties类是Hahstable的子类，该对象操作属性文件特别方便。可以把属性文件中”属性名=属性值”加载到Map对象中。由于属性文件的属性名和属性值只能是字符串，所以Properties的key、value都是String类型。该类提供了如下三个方法修噶Properties的key、value值:</p>
<ul>
<li>String getProperty(String key):获取Properties指定属性名对应的属性值</li>
<li>String getProperty(String key, String defaultValue):与上面相似，如果不存在指定key的时候返回默认value</li>
<li>Object setProperty(String key, String value):设置属性值</li>
<li>void load（InputStream inStream）:从属性文件加载key-value</li>
<li>void store(OutputStream out, String comments):将Properties中的key-value输出到指定的属性文件中。</li>
</ul>
<h3 id="几种特殊的Map实现类"><a href="#几种特殊的Map实现类" class="headerlink" title="几种特殊的Map实现类"></a>几种特殊的Map实现类</h3><p>WeakHashMap与hashMap用法相似。区别在于HashMap的可以保留了对象的强引用，意味着HahsMap对象不销毁，所引用的key就不会被垃圾回收；WeakHashMap的可以只保留了实际对象的弱引用，意味着WeakHashMap对象的key没有被其他强引用的话可能会被垃圾回收；</p>
<p>IdentityhashMap实现类的机制与hashMap基本相似，区别在于：IdentityhashMap只有key1==key2，IdentityhashMap才认为这两个key相等；HashMap而言，只要key1和key2通过equals()比较返回true且他们的hashCOde相等即可。</p>
<p>EnumMap是一个与枚举类一起使用的Map实现类。EnumMap的所有key必须是单个枚举类的枚举值</p>
<h3 id="Collections工具类的用法"><a href="#Collections工具类的用法" class="headerlink" title="Collections工具类的用法"></a>Collections工具类的用法</h3><p>Collections提供了如下常用的类方法对List集合中元素进行排序：</p>
<ul>
<li>void reverse(List list):对集合进行反转</li>
<li>void shuffle(List list):对集合进行随机排序</li>
<li>void sort(List list): 对集合进行自然顺序进行升序排序</li>
<li>void sort(List list, Comparator c): 根据Comparator产生的顺序进行排序</li>
<li>void swap(List list, int i, int j): 指定集合索引i和j的元素互换</li>
<li>void rotate(List list, int distance): 当distance为正数时，将list集合的后distance个元素”整体”移到前面，当distance为负数时，将list集合的前distance个元素”整体”移到后面，该方法不修改集合的长度</li>
</ul>
<p>Collections提供了如下常用的类方法用于查找、替换集合元素：</p>
<ul>
<li>int binarySearch(List list, Object key):使用二分法搜索指定List集合，获得指定对象在List中的位置</li>
<li>Object max(Collection coll):根据元素的自然顺序，返回集合中的最大元素</li>
<li>Object max(Collection coll, Comparator com):根据Comparator指定顺序，返回集合最大元素</li>
<li>Object min(Collection coll):根据元素的自然顺序，返回集合中的最小元素</li>
<li>Object min(Collection coll, Comparator com):根据Comparator指定顺序，返回集合最小元素</li>
<li>void fill(List list, Object obj):使用指定obj元素替换List集合所有的元素</li>
<li>int frequency(Collection c, Object o):返回指定集合中指定元素出现的次数</li>
<li>int indexOfSubList(List source, List target): 返回子list对象在父List对象中第一次出现的索引，如果没有返回-1</li>
<li>int lastOfSubList(List source, List target): 返回子list对象在父List对象中最后一次出现的索引，如果没有返回-1</li>
<li>boolean replaceAll(List list, Object oldVal, Objet newVal):将list中所有oldVal替换成newVal</li>
</ul>
<p>Collections类中提供了多synchronizedXxx()方法，该方法可以指定集合包装成线程同步的集合，从而解决多线程并发访问集合时线程安全的问题。</p>
<p>Collections提供如下三个类方法返回一个不可变的集合</p>
<ul>
<li>emptyXxx():返回一个空的、不可变集合对象</li>
<li>singletonXxx():返回一个只包含指定对象的不可变得集合对象</li>
<li>unmodifiableXxx():返回指定集合对象不可变视图</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础(三)]]></title>
      <url>/2017/06/01/Java%E5%9F%BA%E7%A1%80-%E4%B8%89/</url>
      <content type="html"><![CDATA[<p>Java为8个基本类型提供了对应的包装类，可以把8个基本类型包装成对象使用，JDK1.5后提供了自动装箱和自动拆箱功能，允许基本类型值可以直接赋给包装类的引用变量，也允许把包装类直接赋给基本类型变量。<br>Java提供了final关键字修饰变量、方法和类，不允许为final变量重新赋值，子类不允许覆盖父类的final方法，final类不能派生子类。<br>abstract和interface关键字分别用于定义抽象类和接口,抽象类和接口都是从子类中抽象出来的共同特征。抽象类主要作为多个类的模板，接口则定义多个类遵守的规范。<br>enum关键字用于创建枚举类，枚举类不能创建对象，美军类的对象在定义了类时已经固定下来。</p>
<h3 id="包装类及其用法"><a href="#包装类及其用法" class="headerlink" title="包装类及其用法"></a>包装类及其用法</h3><p>Java中8种基本数据类型不支持面向对象的编程机制也不具备”对象”的特性:没有成员变量、方法可以调用。为了解决8种基本数据类型不能当成Object类型变量使用，Java提供了包装类。<img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-17.png" alt=""><br>在JDK1.5之后Java提供了自动装箱和自动拆箱功能。所谓装箱和拆箱就是可以把一个基本数据类型直接赋值给包装类型，包装类型可以直接赋值给基本数据类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将一个基本数据类型自动装箱赋值给包装类型</span></div><div class="line">Integer inObj = <span class="number">5</span>;</div><div class="line">Object boolOjb = <span class="keyword">true</span>;</div><div class="line"><span class="comment">//将一个包装类型自动拆箱赋值给基本数据类型</span></div><div class="line"><span class="keyword">int</span> it = inOjb;</div><div class="line"><span class="keyword">boolean</span> b = (Boolean)boolOjb;</div></pre></td></tr></table></figure></p>
<p>除此之外，包装类型还可以将基本类型变量与字符串进行转换。把字符串转换成基本类型的值有两种：<br>1、利用包装类型提供<em>parseXxx(String s)</em>静态方法<br>2、利用包装类提供构造器<em>Xxx(String s)</em><br>String类型提供多个重载valueOf()方法，用于将基本数据类型转换成字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String intStr = <span class="string">"123"</span>;</div><div class="line"><span class="comment">//通过包装类静态方法将字符串转换成基本数据变量</span></div><div class="line"><span class="keyword">int</span> it1 = Integer.parseInt(intStr);</div><div class="line"><span class="comment">//通过包装类构造方法将字符串转换成基本数据变量</span></div><div class="line"><span class="keyword">int</span> it2 = <span class="keyword">new</span> Integer(intStr);</div><div class="line"><span class="comment">//通过String的valueOf静态方法，将基本数据类型转换成String类型</span></div><div class="line">String strValue = String.valueOf(it2);</div></pre></td></tr></table></figure></p>
<p>包装类型进行比较：如果一方不是包装类型那么比较的是两方的值。如果两方都是包装类型比较的是指针，但是如果比较Integer类型小于128的可以进行比较，因为Java将128以下进行缓存。Java7为所有包装类提供了静态的<em>compare(xxx val1, xxx val2)</em>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Boolean.compare(<span class="keyword">true</span>, <span class="keyword">false</span>);<span class="comment">//1</span></div><div class="line">Boolean.compare(<span class="keyword">true</span>, <span class="keyword">true</span>);<span class="comment">//0</span></div><div class="line">Boolean.compare(<span class="keyword">false</span>, <span class="keyword">true</span>);<span class="comment">//-1</span></div></pre></td></tr></table></figure></p>
<h3 id="toString方法的用法"><a href="#toString方法的用法" class="headerlink" title="toString方法的用法"></a>toString方法的用法</h3><p>toString()是Object类的一个实例方法，所有的Java类都是Object的子类，因此所有类都具有toString()方法。<br>toString()是一个“自我描述的方法”,直接打印该对象，系统输出”类名+@+hashCode”值。用户可以重写toString()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Person p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//打印toString返回的信息，默认返回"类名+@+hashCode"</span></div><div class="line">System.out.print(p);</div></pre></td></tr></table></figure></p>
<h3 id="和equals方法"><a href="#和equals方法" class="headerlink" title="==和equals方法"></a>==和equals方法</h3><p>Java程序测试两个变量是否相等有两种方式:==和equals()方法。基本数据类型的两个变量值通过==判断。如果是引用变量，当两个变量指向同一个指针的时候==返回true,==不可用于比较类型上没有父子关系的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i1 = <span class="number">65</span>;</div><div class="line"><span class="keyword">int</span> i2 = <span class="number">65</span>;</div><div class="line">i1 == i2; <span class="comment">//true</span></div><div class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</div><div class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</div><div class="line">String s3 = s1;</div><div class="line">s1 == s2;<span class="comment">//false</span></div><div class="line">s1 == s3;<span class="comment">//true</span></div><div class="line">s1 == i1;<span class="comment">//编译错误</span></div></pre></td></tr></table></figure></p>
<p>equals()方法是判断两个对象的值相等，但是这个值相等的标准是自定义的；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="comment">//重写equals()方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == Person.class) &#123;</div><div class="line">            Person p = (Person)obj;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getIdStr().equals(p.getIdStr())) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>static关键字修饰的成员是类成员包括类变量、类方法、静态初始化块、内部类。static不能修饰构造器。static修饰的类成员数据整个类，不属于单个实例。<br>当系统第一次准备该类时，系统会为类成员分配内存空间，类成员开始生效，知道该类被卸载，该类的类成员才会被垃圾回收器回收。</p>
<h3 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h3><p>如果一个类始终只能创建一个实例，则这个类被称为单例类。在一些特殊情况下，不允许自由创建类对象，应把该类的构造器使用private修饰。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = newSingleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h3><p>final修饰可用于修饰类、变量和方法，表示他修饰的类、方法和变量不可改变。final修饰的变量不可被改变，一旦获得初始值，该final变量的值就不能被重新赋值。final修饰的方法不可被重写，如果父类不希望子类重写某个方法，则可以使用fianl修饰该方法。final修饰的类不可以有子类。</p>
<h3 id="abstract关键字的用法"><a href="#abstract关键字的用法" class="headerlink" title="abstract关键字的用法"></a>abstract关键字的用法</h3><p>抽象方法和抽象类必须使用abstract修饰。 有抽象方法的类一定是抽象类，抽象类不一定有抽象方法。</p>
<ul>
<li>抽象类和抽象方法必须用abstract修饰，抽象方法没有方法体。</li>
<li>抽象类不能被实例化</li>
<li>抽象类可以包含成员变量、方法(普通方法和抽象方法)、构造器、初始化块、内部类。</li>
<li>含有抽象方法的类只能被定义成抽象类。</li>
</ul>
<p>抽象类不能创建实例，只能当做父类继承。抽象类是从多个具体类中抽象出来的父类，具有更高层次的抽象。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口可以看做是一种更加特殊的”抽象类”。接口不能包含普通方法，接口中所有的方法都是抽象方法。Java8允许接口中定义默认方法，默认方法可以提供方法实现。定义接口不使用class关键字，使用interface关键字。接口支持多继承。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[修饰符] <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口1, 父接口2... </span>&#123;</div><div class="line">    <span class="comment">//零个到多个常量定义...</span></div><div class="line">    <span class="keyword">int</span> MAX_SIZE = <span class="number">50</span>; <span class="comment">//系统会为成员变量默认添加 public static final</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">50</span>;</div><div class="line">    <span class="comment">//零个到多个抽象方法定义...</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>; <span class="comment">//系统会为成员变量默认添加 public abstract</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> out;</div><div class="line">    <span class="comment">//零个到多个内部类、接口、枚举定义...     //系统默认添加public static</span></div><div class="line">    <span class="comment">//零个到多个默认方法或类方法定义...</span></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... msgs)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String msg: msgs) &#123;</div><div class="line">            System.out.println(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//类方法</span></div><div class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">staticTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"接口里的类方法"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>接口定义的是一种规范，因此接口不能包含构造器和初始化块。接口可以包含成员变量(只能是静态常亮)、方法(只能是抽象实例方法、类方法、默认方法)、内部类定义；<br>一个类可以实现一个或多个接口，使用implements关键字。该类必须完全实现接口定义的抽象方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1, 接口2...</span>&#123;</div><div class="line">    <span class="comment">//类体部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>接口和抽象很像，都具有如下特征:</p>
<ul>
<li>接口和抽象类都不能被实例化，他们都位于继承书的顶端，用于被其他实现和继承.</li>
<li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类都必须实现这写抽象方法。<br>接口和抽象的区别：</li>
<li>接口不能为普通方法提供实现</li>
<li>接口不能定义静态方法</li>
<li>接口只能定义静态常亮，不能定义普通成员变量</li>
<li>接口不包含构造器</li>
<li>就扣不包含初始化块</li>
<li>一个类最多能有一个直接父类，但一个类可以有多个接口实现</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>把一个类放在另一个类的内部定义，这个定义在其他类内部的类称为内部类，包含内部类的类称为外部类。内部类主要有如下作用:</p>
<ul>
<li>内部类提供更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</li>
<li>内部类成员可以直接访问外部类的私有数据，但外部类不能访问内部类的实现细节</li>
<li>匿名内部类适用于创建那些仅需要使用一次。</li>
<li>内部类比外部类可以多使用三个修饰符:private、protected、static</li>
<li>非静态内部类不能拥有静态成员</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用static修饰一个内部类，则这个内部类属于外部类本身，而不属于外部类的某个对象，成这个内部类为静态内部类。</p>
<ol>
<li>在外部类使用内部类: 与正常使用普通类没有太大区别，通过new调用内部类的构造器创建实例</li>
<li>在外部类以外使用非静态内部类: 看内部类的修饰符外部类是否可以访问，private只有外部类可以使用。<code>OutClass.InnerClass varName = new OutClass().new InnerClass()</code></li>
<li>在外部类以外使用静态内部类:因为静态内部类是外部类类相关的，因此创建静态内部类对象无须创建外部类对象。在外部类以外的地方创建内部类实例的语法<code>OutClass.InnerClass varName = new OutClass.InnerClass</code><br>局部内部类:如果把一个内部类放到方法里定义，则这个内部类是局部内部类。局部内部类只有在该方法有效。<br>匿名内部类: 匿名内部类必须继承一个父类或实现一个接口。 匿名内部类不能是抽象类，匿名内部类不能定义构造器。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> 实现接口() | 父类构造器(实参列表) &#123;</div><div class="line">    <span class="comment">//匿名内部类的类体部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Lambda表达式与函数式接口"><a href="#Lambda表达式与函数式接口" class="headerlink" title="Lambda表达式与函数式接口"></a>Lambda表达式与函数式接口</h3><p>Lambda表达式是Java8的重要更新。Lambda表达式支持将代码块作为方法参数，Lambda表达式允许使用更简洁的代码创建只有一个抽象方法的接口的实例。Lambda表达式的类型称为”目标类型”，Lambda表达式的目标类型必须是”函数式接口”, 函数式接口代表只包含一个抽象方法的接口，可以包含多个默认方法、类方法，但只能包含一个抽象方法。</p>
<h4 id="Lamdba入门"><a href="#Lamdba入门" class="headerlink" title="Lamdba入门"></a>Lamdba入门</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用匿名内部类的例子</span></div><div class="line">ProcessArray pa = <span class="keyword">new</span> ProcessArray();</div><div class="line">pa.process(target, <span class="keyword">new</span> Command()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> tmp : target) &#123;</div><div class="line">            sum += tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//使用Lambda表达式可简化创建匿名内部类</span></div><div class="line">ProcessArray pa = <span class="keyword">new</span> ProcessArray();</div><div class="line">pa.process(target, (<span class="keyword">int</span>[] target)-&gt;&#123;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> tmp : target) &#123;</div><div class="line">            sum += tmp;</div><div class="line">        &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Lambda表达式主要作用就是代理匿名内部类的繁琐语法，由三部分组成。</p>
<ul>
<li>形参列表。形参列表允许省略形参类型。如果形参列表只有一个参数，甚至括号也可以省略</li>
<li>箭头 (-&gt;)</li>
<li>代码块</li>
</ul>
<p>下面程序示范Lambda表达式的几种简化写法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String weather)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LamdbaQs</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Eatable e)</span> </span>&#123;</div><div class="line">        System.out.println(e);</div><div class="line">        e.taste();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Flyable f)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"我正在驾驶:"</span> + f);</div><div class="line">        f.fly(<span class="string">"[碧空如洗的晴日]"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Addable add)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"5与3的和为:"</span> + add.add(<span class="number">5</span>, <span class="number">3</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LamdbaQs mainT = <span class="keyword">new</span> LamdbaQs();</div><div class="line">        mainT.eat(()-&gt; System.out.println(<span class="string">"苹果的味道不错"</span>));</div><div class="line">        mainT.drive(weather-&gt;&#123;</div><div class="line">            System.out.println(<span class="string">"今天的天气是:"</span> + weather);</div><div class="line">            System.out.println(<span class="string">"直升机飞行平稳"</span>);</div><div class="line">        &#125;);</div><div class="line">        mainT.test((da , b)-&gt;da + b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Lambda方法引用与构造器引用"><a href="#Lambda方法引用与构造器引用" class="headerlink" title="Lambda方法引用与构造器引用"></a>Lambda方法引用与构造器引用</h4><p>方法引用和构造器引用可以让Lambda表达式的代码块更加简洁。Lambda表达式如下图所示:<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-18.png" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FuncationalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span> </span>&#123;</div><div class="line">    <span class="function">Integer <span class="title">convert</span><span class="params">(String from)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//引用类方法</span></div><div class="line">Converter converter1 = from -&gt; Integer.valueOf(from);</div><div class="line">Converter Converter2 = Integer::valueOf;</div><div class="line"><span class="comment">//引用特定对象的实例方法</span></div><div class="line">Converter converter3 = from -&gt; <span class="string">"fkit.org"</span>.indexOf(from)</div><div class="line">Converter converter4 = <span class="string">"fkit.org"</span>::indexOf;</div><div class="line"><span class="comment">//引用某类对象的实例方法</span></div><div class="line"><span class="meta">@FuncationalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyTest</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">test</span><span class="params">(String a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>;</div><div class="line">&#125;</div><div class="line">MyTest mt = (a, b, c) -&gt; a.substring(b, c);</div><div class="line">MyTest mt = String::substring;</div><div class="line"><span class="comment">//引用构造器</span></div><div class="line"><span class="meta">@FuncationalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">YourTest</span> </span>&#123;</div><div class="line">    <span class="function">JFrame <span class="title">win</span><span class="params">(String title)</span></span>;</div><div class="line">&#125;</div><div class="line">YourTest yt = (String a) -&gt; <span class="keyword">new</span> JFrame(a);</div><div class="line">YourTest yt = JFrmae::<span class="keyword">new</span>;</div></pre></td></tr></table></figure></p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>Java5新增enum关键字，用来定义枚举类。枚举类是一种特殊的类，他一样可以有成员变量、方法，可以实现一个或多个接口，也可以定义自己的构造器。枚举类与普通类的区别:</p>
<ul>
<li>枚举类可以实现一个或多个接口，使用enum定义枚举类默认继承java.lang.Enum类,而不是Ojbect类，因此枚举不能显示继承其他父类。</li>
<li>使用enum定义、费抽象的枚举类默认会使用final修饰，不能派生子类</li>
<li>枚举类的构造器只能使用private访问控制符</li>
<li>枚举类的所有实例必须在枚举类第一行显示列出，否则这个枚举类永远都不能产生实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum &#123;</div><div class="line">    <span class="comment">//在第一行列出2个枚举实例</span></div><div class="line">    MALE(<span class="string">"男"</span>),FEMALE(<span class="string">"女"</span>)；</div><div class="line">    <span class="comment">//定义一个public修饰的实例变量</span></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Gender</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="垃圾回收和对象的finalize方法"><a href="#垃圾回收和对象的finalize方法" class="headerlink" title="垃圾回收和对象的finalize方法"></a>垃圾回收和对象的finalize方法</h3><p>垃圾回收机制具有如下特征:</p>
<ul>
<li>垃圾回收机制只负责回收内存中的对象，不回收任何物理资源</li>
<li>程序无法精准控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性的是去引用后，系统就会在合适的时候回收他所占的内存.</li>
<li>在垃圾回收机制任何对象之前，总会先调用它的finalize()方法，该方法可能会使该对象复活，从而导致垃圾回收机制取消回收。<br>垃圾回收机制在内存中的状态：</li>
<li>可达状态：当一个对象创建后，有一个以上的引用变量引用它，则这个对象在程序中处于可达状态</li>
<li>可恢复状态: 如果程序中某个对象没有变量引用，它就进入可恢复状态。这种状态下，系统的垃圾回收机制准备回收该对象暂用的内存，在回收之前系统会调用所有可恢复状态的finalize()方法进行资源清理。如果系统在finalize()方法是重新让一个引用变量引用该对象，该对象再次变为可达状态</li>
<li>不可达撞他：对象无人引用，并且系统已经调用finalize()方法，该对象永久性是去引用。</li>
</ul>
<p>强制系统进行垃圾回收-这种强制只是通知系统进行垃圾回收，单系统是否进行垃圾回收依然不确定。垃圾回收有两种方式:</p>
<ul>
<li>调用Systen.gc();</li>
<li>调用Runtime.getRuntime().gc();</li>
</ul>
<h3 id="修饰符的使用范围"><a href="#修饰符的使用范围" class="headerlink" title="修饰符的使用范围"></a>修饰符的使用范围</h3><p><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-19.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础(二)]]></title>
      <url>/2017/05/26/Java%E5%9F%BA%E7%A1%80-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p>Java是面向对象的程序语言设计，Java语言提供了定义类、成员变量、方法等基本功能。类可以看做是自定义的一种数据类型，可以使用类定义变量，所有使用类定义的变量都是引用变量。</p>
<p>Java支持面向对象的三大特征：封装、继承和多态，Java提供了Private、protected和public三个访问控制修饰符来实现良好的封装，提供extends关键字可以让子类继承父类，子类继承父类就可以继承父类的成员变量和方法，如果访问控制允许，子类就可以直接调用父类的方法。使用继承关系，子类可以直接赋给父类变量，这个变量具有多态性;<br>构造器御用对类实例进行初始化操作，构造器支持重载。Java嗨提供了初始化块，可以在构造器之前被调用。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象是一种程序设计方法。基本思想是使用类、对象、继承、封装等基本概念进行程序设计。面向对象开发的软件系统，其最小的程序单元是类，这些类可以生成多个对象，这些对象映射客观世界的各种事务。<strong>成员变量(状态数据)+方法(行为) = 类定义</strong> ； 面向对象的程序单位是类，面向过程的程序单位是方法。<br>面向对象方法的三个基本特征：封装、继承和多态。除此之外抽象也是作为面向对象的重要特征。<br>&emsp; 1. &nbsp; 封装：将对象的实现细节隐藏起来，通过一些公用方法来暴露对象的功能；<br>&emsp; 2. &nbsp; 继承：是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；<br>&emsp; 3. &nbsp; 多态：指子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，意味着同一个类型的对象在执行同一个方法是，可能表现出多种行为特征。</p>
<h3 id="Java的面向对象特征"><a href="#Java的面向对象特征" class="headerlink" title="Java的面向对象特征"></a>Java的面向对象特征</h3><p>在Java的世界里，一切皆对象，任何事务都可以当初对象来看待。在Java中，任何具有相同或相似性质的一组对象的抽象就是类，<font color="red">类是一类事务的描述，是抽象的、概念上的定义。它规定了某类对象所共同的行为特征和数据。</font> 对象的抽象化是类，类的具体化是对象。<br>在客观世界中有若干类，这些类之间有一定的结构关系，通常有如下两种主要结构关系。<br>&emsp; 1. &nbsp; “is-a”: Java语言使用extends关键字来表示这种继承关系，Java的子类是一种特殊的父类，可以看做 子类 is a 父类。<br>&emsp; 2. &nbsp; “has-a”: 整体-&gt;部分结构关系，也被成为组装结构，Java语言通过在一个类中保存另一个对象的引用来实现这种组合关系。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>Java语言定义类的简单语法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</div><div class="line">    <span class="comment">//零到多个构造器定义...</span></div><div class="line">    [修饰符] 构造器名(形参列表)&#123;</div><div class="line">        <span class="comment">//由零到多条可执行性语句组成的方法体</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//零到多个成员变量...</span></div><div class="line">    [修饰符] 类型 成员变量名 [=默认值];</div><div class="line">    <span class="comment">//零到多个方法...</span></div><div class="line">    [修饰符] 方法返回值类型 方法名(形参列表) &#123;</div><div class="line">        <span class="comment">//由零到多条可执行性语句组成的方法体</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>构造器: 构造器是一个类创建对象的根本途径，最少有一个构造对象，如果程序员没有为类编写构造器，那么系统会提供一个默认构造器。如果程序员提供了构造器，系统就不会提供默认构造器。</li>
<li>类的修饰符: public、final、abstract或者省略修饰符</li>
<li>构造器修饰符: 修饰符可以省略, 也可以是public、protected、private其中之一。</li>
<li>构造器名称: 构造器名称必须与类名相同。 </li>
<li>成员变量的修饰符: public、protected、private、static、final，public、protected、private最多出现一个，可以与static、final组合</li>
<li>方法的修饰符: public、protected、private、static、final、abstract，其中public、protected、private最多出现一个；abstract和fianl最多出现一个，可以与static组合</li>
</ol>
<p>static修饰的成员变量和方法称为<font color="red">类变量和类方法.</font> 类变量和类方法属于类不属于对象。成员变量和普通方法属于该类的单个实例不属于类。</p>
<h3 id="package、import和import-static"><a href="#package、import和import-static" class="headerlink" title="package、import和import static"></a>package、import和import static</h3><p>Java里面package的概念：Java里的包用于解决类的命名冲突、类文件管理等问题。可以把Java的包看做是文件夹。为了简化编程可以使用import关键导入指定类或者指定包下的类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//导入指定的类</span></div><div class="line"><span class="keyword">import</span> <span class="keyword">package</span>.subPackage...ClassName;</div><div class="line"><span class="comment">//导入指定的包下的所有类, 这里的*指的是当前包下所有的类，并不包含当前包下子包的类</span></div><div class="line"><span class="keyword">import</span> <span class="keyword">package</span>.subPackage...*;</div><div class="line"><span class="comment">//jdk1.5后添加静态导入的语法</span></div><div class="line"><span class="comment">//导入指定包下静态的方法或者变量</span></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.subPackage...ClassName.filedName|methodName;</div><div class="line"><span class="comment">//例如</span></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*</div><div class="line">out.println(<span class="string">"可以直接调用System类下的out类方法"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="对象创建和使用"><a href="#对象创建和使用" class="headerlink" title="对象创建和使用"></a>对象创建和使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建对象</span></div><div class="line">Person p;</div><div class="line">p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//给对象的成员变量命名</span></div><div class="line">p.name = <span class="string">"李刚"</span>;</div><div class="line"><span class="comment">//调用对象的方法</span></div><div class="line">p.say(<span class="string">"hello world"</span>);</div><div class="line"><span class="comment">//调用系统输出对象的名称</span></div><div class="line">System.out.println(p.name);</div></pre></td></tr></table></figure>
<p>栈内存中的引用变量存储Person对象的指针，堆内存中创建Person对象。下面展示内存中使用Person的引用图：<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-14.png" alt=""></p>
<p>Java提供了this、super关键字。<font color="red">this代表当前对象、super代表父类对象</font>。由于static修饰的变量和方法属于类不属于对象，所以不能在类方法中使用this、super关键字。大部分情况下可以省略this关键字。<br>this作为对象的默认引用有两种情形：<br>&emsp; 1. 构造器中引用该构造器正在初始化对象。<br>&emsp; 2. 在方法中调用该方法的对象。</p>
<p>在Java语言中，根据定义变量的位置不同可以将变量分成两类：成员变量和局部变量。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-15.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类变量引用</span></div><div class="line">类.类变量</div><div class="line"><span class="comment">//成员变量引用</span></div><div class="line">实例.实例变量</div></pre></td></tr></table></figure>
<p>Java方法的参数传递机制: Java方法的参数传递方式只有一种:值传递，也就是将实际参数复制传入方法内，参数本身不会受到影响。基本数据类型传递不会有迷茫。引用数据类型传递，是将指针复制传递给形参，但是实参和形参指向同一块内存空间，当形参修改堆内存中的数据从外面看实参指向的内存空间也被修改了。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-16.png" alt=""><br>Java形参个数可变的方法:在jdk1.5之后，Java语序定义形参个数可变的参数，只能在最后有一个参数后面添加可变参数。可以将可变参数当做数组参数看待。使用格式(…)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, string... books)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="深入构造器"><a href="#深入构造器" class="headerlink" title="深入构造器"></a>深入构造器</h4><blockquote>
<p>疑问：构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？<br>答：不是！ 构造器是创建Java对象的重要途径，通过new关键字调用构造器是，构造器也确实返回了该类的对象，但这个对象并不是完全由构造器负责创建的。实际上，当程序员调用构造器时，系统会先为该对象分配内存空间，并为这个对象执行默认初始化，这个对象已经产生了——这些操作在狗在其执行之前就执行完成了。也就是说，当系统开始执行构造器的执行体之前，系统已经创建了一个对象，只是这个对象还不能被外部程序访问，只能在构造器中通过this调用。当构造器的执行体执行结束后，这个对象作为构造器的返回值赋给另外一个引用类型的变量，从而让外部程序可以访问对象。</p>
</blockquote>
<h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>Java使用构造器来对单个对象进行初始化操作，与构造器作用非常类似的是初始化块，他也可以对Java对象进行初始化操作。相同类型的初始化块之间有顺序：前面定的的初始化块先执行，后面定义的后执行。如果一个变量在初始化块前定义，在初始化块中可以修改。如果变量在初始化块后面定义，在初始化快中可以修改但是无效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[修饰符] &#123;</div><div class="line">    <span class="comment">//初始化块的可执行代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初始化块有两种:一种是静态初始化块，另一种是动态初始化块。<br>&emsp; 1. 静态初始化块：只有在第一次创建该对象的时候走静态初始化块。<br>&emsp; 2. 初始化块：初始化块在执行构造器之前执行，如果有父类先执行父类的初始化块-&gt;父类的构造方法-&gt;子类的初始化块-&gt;子类的构造方法.</p>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>Java允许同一个类中定义多个同名方法，只要形参不同。如果同一个类中包含了两个或两个以上的方法名相同，但形参列表不同，则被称为方法的重载。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是面向对象的三大特征之一。它指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。对于一个类或对象实现良好的封装，可以实现以下目的：</p>
<ul>
<li>隐藏类的实现细节</li>
<li>限制对成员变量的不合理访问</li>
<li>可进行数据检查，有利于保证对象信息的完整性</li>
<li>便于修改，提高代码的可维护性<br>为了实现良好的封装，从两个方面考虑：</li>
<li>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问</li>
<li>把方法暴露出来，让方法来控制对成员变量进行安全的访问操作。<br>Java提供了3个访问修饰符控制访问范围的大小，另外还有一个不加任何访问修饰符的访问级别。如图所示：</li>
<li>private：当前类访问权限，只有单前类能引用</li>
<li>default：包访问权限，只有在同一个包内可以访问</li>
<li>protected：子类访问权限，既可以被同一个包内的其他类访问，也可以被不同包下的子类访问</li>
<li>public：公共访问权限</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一个类中</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>同一个包中</td>
<td></td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>子类中</td>
<td></td>
<td></td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>全局范围内</td>
<td></td>
<td></td>
<td></td>
<td>YES</td>
</tr>
</tbody>
</table>
<h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>继承是面向对象的三大特征之一。也是实现软件复用的重要手段。Java的继承通过extends关键字来实现，实现继承的类被称为子类，被继承的类称为父类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">修饰符 <span class="class"><span class="keyword">class</span> <span class="title">subClass</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</div><div class="line">    <span class="comment">//类定义部分</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子类扩展了父类，子类是一个特殊的父类。子类可以以父类为基础，在此之上添加新的成员变量和方法。子类也可以<font color="red">重写</font>父类的方法。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态是面向对象的三大特征之一。Java引用变量有两个类型：一个是编译时类型，一个是运行时类型。编译时类型是有声明该变量是使用的类型决定，运行时类型是由实际赋给该变量的对象决定的。如果编译时类型和运行时类型不一致，就可能出现所谓的多态。<br>instanceof运算符：前面是引用类型的变量，后面是类，用于判断当前变量是否是后面的类，或者其子类、实现类的实例，如果是ture否则flase;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Object hello = <span class="string">"he"</span>;</div><div class="line">(hello <span class="keyword">instanceof</span> String) <span class="comment">//true</span></div><div class="line">(hello <span class="keyword">instanceof</span> Math) <span class="comment">// false</span></div><div class="line"><span class="comment">//instanceof运算符前面编译时类型要么与后面类型相同，要么与后面具有父子继承关系，否则会引起编译错误</span></div><div class="line">String str= <span class="string">"ddddd"</span>;</div><div class="line">(str <span class="keyword">instanceof</span> Math)<span class="comment">//编译错误</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础(一)]]></title>
      <url>/2017/05/25/Java%E5%9F%BA%E7%A1%80-%E4%B8%80/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h2 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h2><p>Java语言是一门纯粹的面向对象的语言，它吸收了C++语言的优点，摒弃了C++里难易理解的多继承、指针等概念，因此Java具有功能强大和简单易用的两个特征。Java主要分成了Java SE、Java ME、Java EE三个版本。<br>&emsp; 1. Java SE:整个Java技术的核心和基础，是ME和EE的编程的基础。<br>&emsp; 2. Java ME:主要用于控制移动设备和信息家电等有限存储的设备。<br>&emsp; 3. Java EE:Java技术中最广泛的部分，Java EE提供了企业应用开发相关的完整解决方案。</p>
<p>计算机高级语言程序按执行方式可分为编译型和解释型两种。Java语言比较特殊，可以认为他既是编译型语言，也是解释型语言。Java程序需要先编译成字节码文件，然后再由JVM解释执行。<br>Java的垃圾回收机制的优点：<br>&emsp; 1. 垃圾回收机制可以很好的提高编程的效率。在没有垃圾回收机制时，可能要花许多时间解决一个难懂的存储器问题。<br>&emsp; 2. 垃圾回收机制保护程序的完整性，垃圾回收是Java语言安全策略的一个重要部分。<br>垃圾回收机制的缺点:<br>&emsp; 3. 垃圾回收的开销影响程序的性能。</p>
<h2 id="Java数据类型和运算符"><a href="#Java数据类型和运算符" class="headerlink" title="Java数据类型和运算符"></a>Java数据类型和运算符</h2><p>Java是一门强类型语言，所有的变量必须先声明后使用，指定类型的变量只能接受类型与之匹配的值。强类型语言可以在编译过程中发现源码错误，从而提高程序的健壮性。</p>
<h3 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h3><p>标识符就是程序中为变量、类、方法命名的符号名称。Java的标识符必须以字母、下划线、美元符开头。Java语言是区分大小写，因此标识符abc与ABC是不同的。<br>使用标识符要遵守如下规则。</p>
<ul>
<li>标识符由字母、数字、下划线(_)、美元符($)组成，其中数字不能打头;</li>
<li>标识符不能是Java关键字或保留字，但可以包含关键字和保留字;</li>
<li>标识符不能包含空格;</li>
<li>标识符只能包含美元符($),但不能包含@、#等其他特殊字符;</li>
</ul>
<p>Java关键字列表如下:<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-01.png" alt=""></p>
<h3 id="Java的数据类型"><a href="#Java的数据类型" class="headerlink" title="Java的数据类型"></a>Java的数据类型</h3><p>Java的数据类型分为两类: 基本数据类型和引用数据类型。</p>
<ul>
<li>基本数据类型：数值类型、boolean类型和char类型。数值类型又包括整数类型和浮点类型。整数类型包含:byte、short、int、long。浮点类型包含:float和double。</li>
<li>引用数据类型：类、接口和数组类型，还有一种特殊的null类型。所谓的引用数据类型是对一个对象的引用,对象包括实例和数组两种。实际上，引用类型变量就是一个指针，只是Java中不再使用指针这个说法。</li>
</ul>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>基本数据类型包含数值类型和boolean类型。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-02.png" alt=""></p>
<ul>
<li>byte: -2^7 ~ 2^7 -1 在内存中占8位</li>
<li>short: -2^15 ~ 2^15 -1 在内存中占16位</li>
<li>int: -2^31 ~ 2^31 -1 在内存中占32位</li>
<li>long: -2^63 ~ 2^63 -1 在内存中占64位</li>
<li>float: 声明float类型需要在小数末尾加上F或f,在内存中占32位</li>
<li>double: 小数默认double类型，在内存中占64位</li>
<li>char:使用Unicode字符集，使用’’单引号的一个字符，在内存中占16位</li>
<li>bool:只有true和false两个值, Java规范没有强制指定boolean占用的内存空间，但由于大部分计算机分配的最小内存单元是字节(8位),因此大部分时候实际上占用8位</li>
</ul>
<h4 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h4><p>基本数据类型转换有两种转换方式:自动类型转换和强制类型转换。</p>
<ol>
<li><p>自动数据类型转换是指范围小的数据类型想大的数据类型可以进行自动类型转换。可以看下图: <img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-03.png" alt=""></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> iValue = <span class="number">233</span>;</div><div class="line"><span class="keyword">long</span> lValue = iValue;</div></pre></td></tr></table></figure>
</li>
<li><p>强制类型转换是指将大的数据类型转换成小的数据类型，例如long-&gt;int， 需要再其前面加上 括号和强制转换的类型</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> iValue = <span class="number">233</span>;</div><div class="line"><span class="keyword">byte</span> bValue = (<span class="keyword">byte</span>)iValue;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Java的运算符可分为如下几种：</p>
<ul>
<li>算数运算符: +、-、*、/、%、++、–</li>
<li>比较运算符: &gt;、&gt;=、&lt;、&lt;=、==、!=</li>
<li>逻辑运算符: &amp;&amp;、&amp;、||、|、!、\^</li>
<li>位运算符: &amp;、|、~、\^ 、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; </li>
<li>赋值运算符: =</li>
<li>扩展赋值运算符: +=、-=、*=、/=、%=、&amp;=、|=、\^=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</li>
<li>三目运算符: ? : </li>
</ul>
<p>运算符的优先级:</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符说明</th>
<th style="text-align:center">Java运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单目运算符</td>
<td style="text-align:center">++ — ~ !</td>
</tr>
<tr>
<td style="text-align:center">强制类型转换运算符</td>
<td style="text-align:center">(type)</td>
</tr>
<tr>
<td style="text-align:center">乘/除/求余</td>
<td style="text-align:center">* / %</td>
</tr>
<tr>
<td style="text-align:center">加/减</td>
<td style="text-align:center">+ -</td>
</tr>
<tr>
<td style="text-align:center">移位运算符</td>
<td style="text-align:center">&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
</tr>
<tr>
<td style="text-align:center">关系运算符</td>
<td style="text-align:center">&lt; &lt;= &gt;= &gt; instanceof</td>
</tr>
<tr>
<td style="text-align:center">等价运算符</td>
<td style="text-align:center">== !=</td>
</tr>
<tr>
<td style="text-align:center">按位与</td>
<td style="text-align:center">&amp;</td>
</tr>
<tr>
<td style="text-align:center">按位异或</td>
<td style="text-align:center">^</td>
</tr>
<tr>
<td style="text-align:center">按位或</td>
<td style="text-align:center">&#124;</td>
</tr>
<tr>
<td style="text-align:center">条件与</td>
<td style="text-align:center">&amp;&amp;</td>
</tr>
<tr>
<td style="text-align:center">条件或</td>
<td style="text-align:center">&#124;&#124;</td>
</tr>
<tr>
<td style="text-align:center">三目运算符</td>
<td style="text-align:center">?:</td>
</tr>
<tr>
<td style="text-align:center">赋值</td>
<td style="text-align:center">= += -= *= /= &amp;= &#124;= ^= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</td>
</tr>
</tbody>
</table>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p> 无论哪种编程语言，都会提供两种基本的流程控制结构：分支结构和循环结构。分支结构用于实现根据条件选择性的执行某段代码，循环结构则用于实现根据循环条件重复执行某段代码。Java提供了if和switch两种分支结构，并提供了while、do while、for三种循环语句，在jdk5后还提供了foreach循环。并且Java还提供了break和continue来控制程序的循环结构。</p>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>1、if条件语句: 使用boolean值或条件来进行分支的控制。if语句有三种形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种形式</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">boolean</span>) &#123;</div><div class="line">    <span class="comment">//statement...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//第二种形式</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">boolean</span>)&#123;</div><div class="line">    <span class="comment">//statement...</span></div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//statement...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//第三种形式</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">boolean</span>)&#123;</div><div class="line">    <span class="comment">//statement...</span></div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">boolean</span>)&#123;</div><div class="line">    <span class="comment">//statement...</span></div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//statement...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、switch语句由一个控制表达式和多个case标签组成。switch控制表达式的数据类型可以为byte、short、char、int四种整数类型和枚举类型，还有java.lang.String类型(从java7才开始允许)，不能是boolean类型。switch语句的格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (expression)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">case</span> condition1:</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//statment...</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> condition2:</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//statment...</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">default</span>: </div><div class="line">    &#123;</div><div class="line">        <span class="comment">//statment...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>1、while循环执行每次先进行判断在循环。 while循环语法格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (expression) &#123;</div><div class="line">    <span class="comment">//statment...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、do while循环，先执行在判断， do while循环语法格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="comment">//statment...</span></div><div class="line">&#125; <span class="keyword">while</span>(expression)</div></pre></td></tr></table></figure>
<p>3、for循环的基本语法格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ([init_statemnt]; [test_expression]; [iteration_statement]) &#123;</div><div class="line">    <span class="comment">//statment...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4、foreach循环: 遍历数组和集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (type variableName : array | collection) &#123;</div><div class="line">    <span class="comment">//statement....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java语言没有提供goto语句来控制程序的跳转，为了弥补不足，Java提供了continue和break来控制循环。初次之外，return可以结束整个方法，当然也结束了循环。 </p>
<ul>
<li>continue: 跳过当前循环，进入下次循环;</li>
<li>break: 结束当前循环;</li>
</ul>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组是编程语言中常见的一种数据结构，可用于存储多个数据。Java的数组要求所有的数组元素具有相同的数据类型。因此，在一个数组中，数组元素的类型是唯一的，<font color="red">即一个数组只能存储一种数据类型的数据，</font>不能存储多种数据类型的数据。</p>
<blockquote>
<p>因为Java语言是面向对象的语言，而类与类之间可以支持继承关系，这样可能产生的一个数组里可以存放多种数据类型的假象。也就是父类型的数组可以存放不同子类型的内容。</p>
</blockquote>
<p>一旦数组初始化完成，数组在内存中所占的空间被固定下来，<font color="red">因此数组的长度将不可改变的。</font>即使把某个数组元素的数据清空，所占的空间依旧被保留，数组的长度不变。<br>Java数组既可以存储基本数据类型的数据，也可以存储引用类型的数据。只要所有数组元素具有相同的类型即可。</p>
<h4 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h4><p>Java语言支持两种个是定义数组，推荐第一种:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">type[] arrayName;</div><div class="line">type arrayName[];</div></pre></td></tr></table></figure></p>
<p>1、静态初始化：在初始化的时候赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] arrayName;</div><div class="line">arrayName = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</div><div class="line"><span class="comment">//可以简化为</span></div><div class="line">type[] arrayName = &#123;element1, element1, element1, element1, ...&#125;;</div></pre></td></tr></table></figure>
<p>2、动态初始化：初始化的时候定义数组的长度，后面赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">type[] array;</div><div class="line">array = <span class="keyword">new</span> type[length];</div></pre></td></tr></table></figure>
<p>动态初始化时，只需要指定数组的长度，即为每个数组元素指定内存空间，系统为这些数组元素分配初始值。</p>
<ul>
<li>数组元素的类型是基本类型的整数类型，默认值0;</li>
<li>数组元素的类型是基本类型的浮点类型，默认值0.0;</li>
<li>数组元素的类型是基本类型的字符类型，默认值’\u0000’;</li>
<li>数组元素的类型是基本类型的布尔类型，默认值false;</li>
<li>数组元素的类型是引用类型，默认值null;</li>
</ul>
<p>数组最常用的用法就是访问数组元素，包括对数组元素进行赋值和取值。所有数组都提供了<font color="red">length</font>属性，通过这个属性可以获取到数组的长度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.print(arrayName[<span class="number">0</span>]);</div><div class="line">arrayName[<span class="number">0</span>] = <span class="string">"ABC"</span>;</div></pre></td></tr></table></figure></p>
<h4 id="深入数组"><a href="#深入数组" class="headerlink" title="深入数组"></a>深入数组</h4><p>数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。</p>
<blockquote>
<p>当一个方法执时，每个方法都会建立自己的内存栈(栈区)，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁。因此，所有在方法中定义的局部变量都是放在栈内存中的；在程序中创建一个对象时，这个对象将被保存在运行时数据区中，以便反复利用(因为对象的创建成本较大)，这个运行时数据区就是堆内存。堆内存中的对象不会随着方法的结束而销毁，局部方法结束后，这个对象还可能被另一个引用变量所引用(在方法的参数传递是很常见)，则这个对象依然不会被销毁。只有当一个对象没有任何引用变量引用他时，系统的垃圾回收器才会在合适的时候回收它。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">20</span>&#125;;</div><div class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">b = a;</div></pre></td></tr></table></figure>
<p>当a、b进行静态初始化的时候开辟了4块内存区，栈内存中有两个引用变量，堆内存中存储a和b引用所指向的数组本身。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-05.png" alt=""><br>当把a赋值给b的时候，a和b都只指向了a原本指向的数组，b引用的数组无人引用，变成了垃圾，等待垃圾回收期将它回收。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-06.png" alt=""></p>
<p>下面再看采用动态初始化，数组在内存空间的变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] iArr;</div><div class="line">iArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; a.length; i++) &#123;</div><div class="line">    iArr[i] = i + <span class="number">10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行第一行代码，定义一个int数组变量这个时候内存中的变化如示意图，栈内存中定义了一个空引用(空引用没有指向任何有效的内存)<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-07.png" alt=""><br>当iArr = new int[5];动态初始化的时候，系统将负责为改数组分配内存空间，将分配默认值0。并且栈内存中的引用指向这个数组<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-08.png" alt=""><br>下面遍历循环赋值，将数组中的元素值修改<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-09.png" alt=""></p>
<p>下面引用数据类型的数组在内存空间的变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Person[] students;</div><div class="line">students = <span class="keyword">new</span> Person[<span class="number">2</span>];</div><div class="line"></div><div class="line">Person zhang = <span class="keyword">new</span> Person();</div><div class="line">zhang.age = <span class="number">15</span>;</div><div class="line">zhang.height = <span class="number">158</span>;</div><div class="line"></div><div class="line">Person lee = <span class="keyword">new</span> Person();</div><div class="line">lee.age = <span class="number">16</span>;</div><div class="line">lee.height = <span class="number">161</span>;</div><div class="line"></div><div class="line">students[<span class="number">0</span>] = zhang;</div><div class="line">students[<span class="number">1</span>] = lee;</div></pre></td></tr></table></figure></p>
<p>执行Person[] students;这时将在栈内存中定义一个引用变量，也就是一个指针，指针并未指向任何有效的内存区。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-10.png" alt=""><br>执行students = new Person[2];这时将在堆内存中分配内存空间，并且分配默认值 null。并将指针指向这块内存区域。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-11.png" alt=""><br>紧接着创建两个Person对象，在栈内存中分配两块内存区域存储指针，然后在堆内存中创建两块区域存储Person实例，并且指针指向对应的Person实例。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-12.png" alt=""><br>下面将Person实例赋值到数组中，这是数组中的元素指向对应的Person实例，无论修改zhang变量所指向的Person实例还是修改students[0]所指向的Person实例，所修改的是同一个内存区，所以必然互相影响。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-06-01-13.png" alt=""></p>
<h4 id="工具类：Arrays"><a href="#工具类：Arrays" class="headerlink" title="工具类：Arrays"></a>工具类：Arrays</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用二分法查询key元素在a数组中的索引；不包含返回负数。使用该方法要求数组按照升序排序才能得到正确结构</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(type[] a, type key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//使用二分法查询key元素在a数组中fromIndex到toIndex索引的索引；不包含返回负数。使用该方法要求数组按照升序排序才能得到正确结构</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(type[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, type key)</span></span>;</div><div class="line"><span class="comment">//把original数组复制成一个新的数组，其中length是新数组的长度。如果length小于original数组的长度 则 新数据就是原数组前面的length个元素，如果大于original数组的长度，则新数组前面元素与原数组元素一样，后面为默认值。</span></div><div class="line">type[] copyOf(type[] original, <span class="keyword">int</span> length);</div><div class="line"><span class="comment">//与上面相似，但只能复制原数组from到to索引的元素</span></div><div class="line">type[] copyOf(type[] original, <span class="keyword">int</span> from, <span class="keyword">int</span> to);</div><div class="line"><span class="comment">//如果a与b长度相同，并且数组元素也意义相同，则返回true</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(type[] a, type[] b)</span></span>;</div><div class="line"><span class="comment">//该方法将a数组中所有元素都赋值为val</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(type[] a, type val)</span></span></div><div class="line"><span class="function"><span class="comment">//该方法将a数组中下标从fromIndex到toIndex下标都赋值为val</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(type[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, type val)</span></span></div><div class="line"><span class="function"><span class="comment">//对该方法a数组进行排序</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(typep[] a)</span></span>;</div><div class="line"><span class="comment">//对该方法a数组fromIndex到toIndex下标内进行排序</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(typep[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</div><div class="line"><span class="comment">//将数组转换成字符串，以英文逗号(,)和空格隔开</span></div><div class="line"><span class="function">String <span class="title">toString</span><span class="params">(type[] a)</span></span>;</div></pre></td></tr></table></figure>
<p>问题记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java使用的Char是Unicode还是Ascll编码？</span></div><div class="line">Unicode</div><div class="line"><span class="comment">//Java的char是否可以保存一个汉字？</span></div><div class="line">可以</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UIApplicationDelegate详解]]></title>
      <url>/2017/05/09/UIApplicationDelegate%E4%BA%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>UIApplicationDelegate是在APP应用程序生命周期内由UIApplication单例对象针对不同的事件调用不同的方法进行处理。UIApplication在应用开始负责初始化并显示UIWindow,并负责加载应用程序的第一个UIView到UIWIndow中。UIApplication另一个任务是帮助管理应用程序的声明周期，而UIApplication会通过UIApplicationDelegate的实现类实现这些任务。UIApplication可以处理的时间包括应用程序的生命周期、系统事件。</p>
<a id="more"></a>
<h2 id="APP启动"><a href="#APP启动" class="headerlink" title="APP启动"></a>APP启动</h2><p>下面介绍app生命周期涉及到的方法。<br>当app开始运行前存在一个启动阶段，这个阶段包含两个系统方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)launchOptions <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"> </div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)launchOptions;</div></pre></td></tr></table></figure>
<p>willFinishLaunchingWithOptions是程序启动但还没进入状态保存，first initialization. didFinishLaunchingWithOptions 程序启动基本完成，程序准备开始运行 final initialization.<br>这两个方法包含一个名称launchOptions的NSDictionary类型的字典，存储的是程序启动的原因。</p>
<ul>
<li>用户点击图标直接启动程序，launchOptions无数据。</li>
<li>其他程序通过openURL:方式启动，则可以通过UIApplicationLaunchOptionsURLKey来获取传递过来的url<br><code>NSURL *url = (NSURL *)[launchOptions valueForKey:UIApplicationLaunchOptionsURLKey];</code></li>
<li>由本地通知启动，则可以通过key: UIApplicationLaunchOptionsLocalNotificaitonKey来获取本地通知对象(UILocalNotification)</li>
<li>由远程通知启动，则可以通过key: UIApplicaitonLaunchOptionsRemoteNotificationKey来获取远程通知信息(NSDictionary)<br>程序launchOptions中的可能键值可以参考UIApplication Class Reference的”Launch Options Keys”.<br>这两个方法的返回值都是一个BOOL类型，将决定是否处理URL资源，如果返回YES，则会由application:openURL:sourceApplication:annotation:方法处理URL。如果应用程序是由远程通知启动，返回值会被忽略。<br><em>p.s.</em> 如果同时出现willFinishLaunchingWithOptions和didFinishLaunchingWithOptions方法，那么这两个返回值都要是YES才会处理URL资源。</li>
</ul>
<p>当程序准备完毕后，接下来就是要进入活动状态，程序进入活动状态执行方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application;</div></pre></td></tr></table></figure>
<p>假如说这时手机来了电话，或者按home键退回桌面，这时应用程序会将从活动状态转换成非活动状态，这时会执行如下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application;</div></pre></td></tr></table></figure>
<p>紧接着应用程序就就从程序界面返回到桌面或者电话的界面，这时候程序就被推送到后台，这时会执行如下方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0);</div></pre></td></tr></table></figure>
<p>如果想要让程序在后台继续存活就需要在applicationDidEnterBackground方法中向系统申请后台存活，不过如果没有后台任务，在后台存活最大是三分钟。</p>
<p>如果应用程序没有因为内存紧张杀掉你的应用，那么你双击home键，在打开程序这时候就是将程序从后台重新推送到前台，这是会调用applicationWillEnterForeground和applicationDidBecomeActive方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0);</div></pre></td></tr></table></figure>
<p>由第三方app通过URL Scheme唤起你的应用程序，这个时候系统会走如下三个方法，下面的三个方式作用一致但是参数不同，是不同时期回调的方法，在ios9之后推荐使用第三种，从系统api就可以看出第一种是在ios2到ios9使用并且只有一个url参数。第二种是ios4-ios9使用，多了一个sourceApplication参数，是唤起你应用程序的Bundle ID。  第三种就是ios9之后推荐使用的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application handleOpenURL:(<span class="built_in">NSURL</span> *)url <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">9</span>_0, <span class="string">"Please use application:openURL:options:"</span>) __TVOS_PROHIBITED;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url sourceApplication:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)sourceApplication annotation:(<span class="keyword">id</span>)annotation <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">4</span>_2, <span class="number">9</span>_0, <span class="string">"Please use application:openURL:options:"</span>) __TVOS_PROHIBITED;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationOpenURLOptionsKey</span>, <span class="keyword">id</span>&gt; *)options <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</div></pre></td></tr></table></figure>
<p>当系统内存不足，系统会调用下面这个方法，如果为应用程序分配了太多的内存操作系统会终止程序的运行，在终止前会运行这个方法，通常在这里进行内存清理工作，防止程序被终止。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationDidReceiveMemoryWarning:(<span class="built_in">UIApplication</span> *)application;</div></pre></td></tr></table></figure>
<p>当应用程序将要被退出时调用，通常用来保存数据和一些退出前的清理工作。这个需要在info.plist设置UIApplicationExitsOnSuspend的键值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application;</div></pre></td></tr></table></figure>
<p>当系统时间发生变化时执行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationSignificantTimeChange:(<span class="built_in">UIApplication</span> *)application;</div></pre></td></tr></table></figure>
<p>下面两个方法是当statusBar(状态栏)方向将要(will)发生变化时执行和statusBar(状态栏)方向变化完成后执行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application willChangeStatusBarOrientation:(<span class="built_in">UIInterfaceOrientation</span>)newStatusBarOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration;</div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didChangeStatusBarOrientation:(<span class="built_in">UIInterfaceOrientation</span>)oldStatusBarOrientation;</div><div class="line"><span class="comment">// 当状态栏的frame即将要发生改变时执行</span></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application willChangeStatusBarFrame:(<span class="built_in">CGRect</span>)newStatusBarFrame __TVOS_PROHIBITED;   <span class="comment">// in screen coordinates</span></div><div class="line"><span class="comment">// 当状态栏的frame发生改变时执行</span></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didChangeStatusBarFrame:(<span class="built_in">CGRect</span>)oldStatusBarFrame __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<p>当用户注册通知方法之后执行(也就是[[UIApplication sharedApplication] registerUserNotificationSettings:]之后执行)，无论用户是否选择允许通知都会调用该方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didRegisterUserNotificationSettings:(<span class="built_in">UIUserNotificationSettings</span> *)notificationSettings <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<p>用户允许通知在注册推送通知之后，系统会在didRegisterForRemoteNotificationsWithDeviceToken方法接收设备令牌,该令牌可以交给服务端，由服务端推送信息。如果获取令牌device token失败则会走didFailToRegisterForRemoteNotificationsWithError方法，参数error有失败的信息。只能在真机上才能获取token。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)deviceToken <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didFailToRegisterForRemoteNotificationsWithError:(<span class="built_in">NSError</span> *)error <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</div></pre></td></tr></table></figure>
<p>在程序运行状态和前台状态接收到远程推送通知之后调用，当杀死程序来了推送不会走当前方法，ios10之后废弃，建议使用UNUserNotificationCenterDelegate中的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">3</span>_0, <span class="number">10</span>_0, <span class="string">"Use UserNotifications Framework's -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:] for user visible notifications and -[UIApplicationDelegate application:didReceiveRemoteNotification:fetchCompletionHandler:] for silent remote notifications"</span>);</div></pre></td></tr></table></figure>
<p>在程序处于后台或者被杀死状态，收到远程通知，进入下面的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span> result))completionHandler <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div></pre></td></tr></table></figure>
<p>收到本地推送通知执行</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">4</span>_0, <span class="number">10</span>_0, <span class="string">"Use UserNotifications Framework's -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"</span>) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<p>在非本App界面收到本地或者推送消息，下拉消息会有快捷回复的按钮，点击按钮后条用的方法，根据identifier来判断点击的按钮，notification为消息内容，下面第一个是本地推送，第二个是远程推送。下面方法在ios10废弃，建议使用UNUserNotificationCenterDelegate中的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application handleActionWithIdentifier:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)identifier forLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification completionHandler:(<span class="keyword">void</span>(^)())completionHandler <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">8</span>_0, <span class="number">10</span>_0, <span class="string">"Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"</span>) __TVOS_PROHIBITED;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application handleActionWithIdentifier:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)identifier forRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo completionHandler:(<span class="keyword">void</span>(^)())completionHandler <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">8</span>_0, <span class="number">10</span>_0, <span class="string">"Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"</span>) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<p>下面两个方法在推送方面最大的变化就是修改了推送Category的类型，在原本的推送categories的基础上，增加了一个text Action类型，这个参数的目的是用来注册通过通知快捷文字输入的事项。<br>这个categories由一系列的 UIUserNotificationCategory组成。每个UIUserNotificationCategory对象允许添加一组UIMutableUserNotificationAction类型的参数来增加通知栏上的项目。如今iOS9在原有的UIMutableUserNotificationAction类型增加了Text输入类型(UIUserNotificationActionBehaviorTextInput),通过behavior来设置(只有iOS9才拥有的属性)。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application handleActionWithIdentifier:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)identifier forLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification withResponseInfo:(<span class="built_in">NSDictionary</span> *)responseInfo completionHandler:(<span class="keyword">void</span>(^)())completionHandler <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">9</span>_0, <span class="number">10</span>_0, <span class="string">"Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"</span>) __TVOS_PROHIBITED;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application handleActionWithIdentifier:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)identifier forRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo withResponseInfo:(<span class="built_in">NSDictionary</span> *)responseInfo completionHandler:(<span class="keyword">void</span>(^)())completionHandler <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">9</span>_0, <span class="number">10</span>_0, <span class="string">"Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"</span>) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<p>Background Fetch(后台获取) 后台获取是一种智能的轮询机制，他适合需要经常更新内容的程序，想社交网络，新闻或天气的程序。举个例子，如果用户经常在下午1点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。<br>开启后台获取的第一步是在info plist文件中的UIBackgourndModels键值指定使用的特性。勾选Background Fetch。第二步设置一个时间间隔，否则程序永远不会再后台进行数据获取。<code>[application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum]</code> UIApplicationBackgroundFetchIntervalMinimum这个值要求系统尽可能经常去管理应用程序什么时候会被唤醒，但如果不需要这个值，你应该指定你的时间间隔。如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把minimumBackgroundFetchInterval设置为UIApplicationBackgroundFetchIntervalNever，这样可以节省资源。最后一步也就是在下面的代理方法中进行处理。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performFetchWithCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span> result))completionHandler <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<p>当用户使用3D touch进入app不同页面，可以根据shortcutItem字段进行判断进入不同的页面。但是如果 <code>application:willFinishLaunchingWithOptions:</code> 或者<code>application:didFinishLaunchingWithOptions</code> 返回的是NO, # 我也不知道。需要进行测试</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> succeeded))completionHandler <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<p>当程序使用NSURLSession的后台工作配置模式，当session添加多个Task并将程序切换到后台，等所有的task都完成下载，系统会调用下面的方法。如果中途将后台切换回前台，已经下载成功的会调用该方法，其他的会已然走session的delegate</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application handleEventsForBackgroundURLSession:(<span class="built_in">NSString</span> *)identifier completionHandler:(<span class="keyword">void</span> (^)())completionHandler <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div></pre></td></tr></table></figure>
<p>要求委托成对WatchKit应用程序响应请求<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application handleWatchKitExtensionRequest:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)userInfo reply:(<span class="keyword">void</span>(^)(<span class="built_in">NSDictionary</span> * __<span class="keyword">nullable</span> replyInfo))reply <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_2);</div></pre></td></tr></table></figure></p>
<p>当watchkit 程序请求访问HealthKit数据的时候。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationShouldRequestHealthAuthorization:(<span class="built_in">UIApplication</span> *)application <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</div></pre></td></tr></table></figure></p>
<p>applicationProtectedDataWillBecomeUnavailable:受保护的文件当前变为不可用的。<br>applicationProtectedDataDidBecomeAvailable:受保护的文件当前变为可用的<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)applicationProtectedDataWillBecomeUnavailable:(<span class="built_in">UIApplication</span> *)application <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0);</div><div class="line">- (<span class="keyword">void</span>)applicationProtectedDataDidBecomeAvailable:(<span class="built_in">UIApplication</span> *)application    <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0);</div></pre></td></tr></table></figure></p>
<p>禁止使用第三方输入法在程序中运行，如果返回NO，则禁止第三方输入法，强制使用系统的输入法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application shouldAllowExtensionPointIdentifier:(<span class="built_in">UIApplicationExtensionPointIdentifier</span>)extensionPointIdentifier <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div></pre></td></tr></table></figure></p>
<p>ios应用状态恢复， 在ios中会出现锁屏或者home键 程序进入后台，当程序返回前台的时候，用户希望看到的仍是之前操作的内容。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//指定视图控制器</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *) application:(<span class="built_in">UIApplication</span> *)application viewControllerWithRestorationIdentifierPath:(<span class="built_in">NSArray</span> *)identifierComponents coder:(<span class="built_in">NSCoder</span> *)coder <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0); </div><div class="line"><span class="comment">//是否应该保存应用程序的状态</span></div><div class="line">- (<span class="built_in">BOOL</span>) application:(<span class="built_in">UIApplication</span> *)application shouldSaveApplicationState:(<span class="built_in">NSCoder</span> *)coder <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"><span class="comment">//保存的状态是否应该恢复</span></div><div class="line">- (<span class="built_in">BOOL</span>) application:(<span class="built_in">UIApplication</span> *)application shouldRestoreApplicationState:(<span class="built_in">NSCoder</span> *)coder <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"><span class="comment">// 处理保存高级状态的信息</span></div><div class="line">- (<span class="keyword">void</span>) application:(<span class="built_in">UIApplication</span> *)application willEncodeRestorableStateWithCoder:(<span class="built_in">NSCoder</span> *)coder <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"><span class="comment">// 恢复一部分保存的高级状态的信息</span></div><div class="line">- (<span class="keyword">void</span>) application:(<span class="built_in">UIApplication</span> *)application didDecodeRestorableStateWithCoder:(<span class="built_in">NSCoder</span> *)coder <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div></pre></td></tr></table></figure></p>
<p>spotLight功能，在ios9中提供了新的APIs, 允许索引app里面的内容或者界面状态，通过Spotlight来快速显示app的内容。这些新的搜索APIs的三大组件为：</p>
<ul>
<li>NSUserActivity （iOS8 出现的类，提供handoff功能支持）</li>
<li>Core Spotlight （新库，提供Spotlight索引APP内容的功能）</li>
<li>web markup（允许 apps 映射它们的内容到网页上面，然后方便spotlight在网页中快速检索内容。Apple的索引器将会扮演爬虫的角色，在网页上面检索那些被Markup的内容。这些信息在Safari和Spotlight都可以检索。）<br>关键的方法：application:willContinueUserActivityWithType:<br>会自动生成一个NSUserActivity对象，该对象的userInfo中只有一个Key，也就是上面看到的那个key。而对应的value就是在初始化CSSearchableItem时，传入的参数，相对于你的app，它必须是唯一的，同时，你可以传一个nil，但是，app会自动给你生成一个唯一的，作为restore时的唯一标识。<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当活动比预期时间长的时候，是否继续通知</span></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willContinueUserActivityWithType:(<span class="built_in">NSString</span> *)userActivityType <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>User Activity Continuation protocol adopted by UIApplication delegate<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 告诉继续活动期间数据是否可用</span></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application continueUserActivity:(<span class="built_in">NSUserActivity</span> *)userActivity restorationHandler:(<span class="keyword">void</span>(^)(<span class="built_in">NSArray</span> * __<span class="keyword">nullable</span> restorableObjects))restorationHandler <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="comment">// 应用注册远程推送通知失败时激发该方法</span></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didFailToContinueUserActivityWithType:(<span class="built_in">NSString</span> *)userActivityType error:(<span class="built_in">NSError</span> *)error <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="comment">// 更新活动</span></div><div class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didUpdateUserActivity:(<span class="built_in">NSUserActivity</span> *)userActivity <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div></pre></td></tr></table></figure></p>
<p>同意接受云共享请求<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) application:(<span class="built_in">UIApplication</span> *)application userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)cloudKitShareMetadata <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div></pre></td></tr></table></figure></p>
<p>应用视图支持的方向<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)application:(<span class="built_in">UIApplication</span> *)application supportedInterfaceOrientationsForWindow:(<span class="keyword">nullable</span> <span class="built_in">UIWindow</span> *)window  <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github pages + hexo博客搭建]]></title>
      <url>/2017/05/02/github%20Pages%E5%92%8CHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>第一次搭建博客系统，网上搜查了好多资料，现在总结一下，如果以后需要重新安装可以翻看。<br><a id="more"></a></p>
<h2 id="搭建github-pages工程"><a href="#搭建github-pages工程" class="headerlink" title="搭建github pages工程"></a>搭建github pages工程</h2><p><a href="https://pages.github.com/" target="_blank" rel="external">Github pages</a>是一个公共静态页面搭建托管服务，站点可以免费托管在<a href="https://github.com" target="_blank" rel="external">github</a>上，你可以选择使用<a href="https://pages.github.com/" target="_blank" rel="external">Github pages</a>默认提供的域名github.io或者自定义域名来发布站点。<br></p>
<h3 id="创建一个仓库"><a href="#创建一个仓库" class="headerlink" title="创建一个仓库"></a>创建一个仓库</h3><p>在github上，创建一个新的仓库使，使用 <strong>用户名.github.io</strong>作为新仓库的名称，如果仓库的第一部分不匹配用户名，这个仓库不会生效。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-05-03-01.png" alt=""><br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-05-03-02.png" alt=""><br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-05-03-03.png" alt=""></p>
<h3 id="本地克隆仓库"><a href="#本地克隆仓库" class="headerlink" title="本地克隆仓库"></a>本地克隆仓库</h3><p>本地一定要安装git,使用创建好的仓库地址在本地克隆仓库。这里我使用命令行，首先在桌面克隆一份仓库代码，然后进入克隆的仓库文件夹中，创建一个index.html，里面只有一句hello word。然后将index.html推送到远程仓库。推送成功后直接访问 <strong><a href="http://用户名.github.io" target="_blank" rel="external">http://用户名.github.io</a></strong> 就可以访问了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ cd /Users/bhlin/Desktop/</div><div class="line">$ git clone https://github.com/username/username.github.io</div><div class="line">$ cd /Users/bhlin/Desktop/username.github.io</div><div class="line">$ echo &quot;Hello World&quot; &gt; index.html</div><div class="line">$ git add --all</div><div class="line">$ git commit -m &quot;Initial commit&quot;</div><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure>
<h2 id="安装hexo环境"><a href="#安装hexo环境" class="headerlink" title="安装hexo环境"></a>安装hexo环境</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>可以通过Homebrew安装node.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>安装完成后，通过查看版本号验证是否安装成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo -v</div></pre></td></tr></table></figure>
<h3 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用hexo</h3><h4 id="创建hexo初始化文件夹"><a href="#创建hexo初始化文件夹" class="headerlink" title="创建hexo初始化文件夹"></a>创建hexo初始化文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 选择一个文件夹</div><div class="line">$ cd /User/bhlin/Desktop/hexo</div><div class="line"># 初始化hexo</div><div class="line">$ hexo init</div><div class="line"># 本地查看</div><div class="line">$ hexo server</div><div class="line"># 在浏览器中输入localhost:4000可以看到是否成功</div></pre></td></tr></table></figure>
<h4 id="创建草稿内容"><a href="#创建草稿内容" class="headerlink" title="创建草稿内容"></a>创建草稿内容</h4><p>使用命令在草稿文件夹中创建草稿文章，使用命令 <code>hexo new draft &quot;file name&quot;</code> ,创建目录是当前初始化文件夹下的source/_drafts 目录下。</p>
<h4 id="移动草稿内容到发布目录"><a href="#移动草稿内容到发布目录" class="headerlink" title="移动草稿内容到发布目录"></a>移动草稿内容到发布目录</h4><p>使用命令将草稿文件夹下的指定文章移动到发布文件夹下， <code>hexo publish &quot;file name&quot;</code> ,会将/source/_drafts/file name 移动到/source/_posts 目录下。</p>
<h4 id="直接在发布目录下创建文章"><a href="#直接在发布目录下创建文章" class="headerlink" title="直接在发布目录下创建文章"></a>直接在发布目录下创建文章</h4><p>使用命令 <code>hexo new &quot;file name&quot;</code> 就可以直接将文章创建在/source/_posts目录下。</p>
<h3 id="hexo目录结构"><a href="#hexo目录结构" class="headerlink" title="hexo目录结构"></a>hexo目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── .deploy #需要部署的文件</div><div class="line">├── node_modules #Hexo插件</div><div class="line">├── public #生成的静态网页文件 （未生成）</div><div class="line">├── scaffolds #模板</div><div class="line">├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里</div><div class="line">| ├── _drafts #草稿 (未生成)</div><div class="line">| └── _posts #文章</div><div class="line">├── themes #主题</div><div class="line">├── _config.yml #全局配置文件</div><div class="line">└── package.json</div></pre></td></tr></table></figure>
<h3 id="上传到github工程"><a href="#上传到github工程" class="headerlink" title="上传到github工程"></a>上传到github工程</h3><p>我们通过命令<code>hexo server</code>，在浏览器中输入localhost:4000可以看到我们本地生成的页面，如何将这些页面上传到github上面去呢？ 首先我们要将markdown文件生成静态的.html网页， 然后将这些网页上传到github上去，我们可以通过下面的命令生成静态网页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># g 是 generate的缩写，可以用g或者generate</div><div class="line">$ hexo g</div></pre></td></tr></table></figure>
<p>然后我们发现我们的目录中，生成了public 文件夹，我们只要将public文件夹中的内容放我们的github本地仓库中，然后是用github命令，将这些内容推送到远程仓库中，就可以了。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-05-03-04.png" alt=""></p>
<h4 id="另外一种上传github工程"><a href="#另外一种上传github工程" class="headerlink" title="另外一种上传github工程"></a>另外一种上传github工程</h4><p>在发布之前修改根目录下的配置文件_config.yaml， 将github信息放在deploy中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/bhlinGit/bhlinGit.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>配置完成后我们使用hexo的deploy命令直接部署</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 或者我们可以缩写命令: hexo d</div><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<h3 id="hexo常用配置"><a href="#hexo常用配置" class="headerlink" title="hexo常用配置"></a>hexo常用配置</h3><p>在我们的博客目录下存在_config.yml的全局配置文件，这个是我们博客的全局配置文件，注意：在配置文件的冒号后面要留一个空格，否则假爱的时候会报语法错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Site</div><div class="line">title: 名称</div><div class="line">subtitle: </div><div class="line">description: 博客描述</div><div class="line">author: 作者名称</div><div class="line">language: 语言（zh-CN）</div><div class="line">timezone:</div></pre></td></tr></table></figure>
<h4 id="两个-config-yml配置文件"><a href="#两个-config-yml配置文件" class="headerlink" title="两个_config.yml配置文件"></a>两个_config.yml配置文件</h4><p>我们在博客文件夹中至少发现两个_config.yml文件， 一个是在我们的博客文件夹根目录存在，这个是全局配置文件，另外在(theme/landscape)文件夹中也会发现这个文件，这个是主题内容的配置文件，不同主题存在不同的_config.yml配置文件，如果功能是有主题提供，那么这个配置就要在theme目录下的_config.yml配置</p>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>Hexo基本所有的主题安装流程都差不多，我现在用的主题是hexo-theme-next（<a href="https://github.com/iissnan/hexo-theme-next），安装它只有几步：" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next），安装它只有几步：</a><br>1.在博客根目录下执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
<p>2.修改根目录下的_config.yml，即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: next</div></pre></td></tr></table></figure>
<p>关于这个主题提供的更多功能，请移步：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">http://theme-next.iissnan.com/getting-started.html</a></p>
<h2 id="七牛云的图床配置"><a href="#七牛云的图床配置" class="headerlink" title="七牛云的图床配置"></a>七牛云的图床配置</h2><ul>
<li>首页我们要有一个七牛云的账号</li>
<li>登录七牛云，点击对象存储 然后新建存储空间，这里的存储空间名称就是你的bucket标识符，后面会用到，选择你想要存储的区域，然后确定创建<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-05-03-05.png" alt=""><br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-05-03-06.png" alt=""></li>
<li>点击内容空间，可以看到你外链默认域名， 这个默认域名+指定的前缀名+文件名，组成了一个完成的图片链接。选择上传文件，就可以将你图片的文件上传到七牛云上面，然后复制外链就可以了。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-05-03-07.png" alt=""><h3 id="qshell的使用"><a href="#qshell的使用" class="headerlink" title="qshell的使用"></a>qshell的使用</h3>上面完全是根据七牛云的页面来进行操作，如果你上传的文件比较多，那么一个一个上传就显得很繁琐，这样我们就可以根据七牛云提供的qshell命令来进行批量上传。qrsync已经废弃了，建议使用qshell来上传。qshell下载地址<a href="http://devtools.qiniu.com/qshell-v2.0.6.zip" target="_blank" rel="external">http://devtools.qiniu.com/qshell-v2.0.6.zip</a>根据你电脑的平台选择不同的命令,例如我是mac osx64位的系统我选择的是qshell_darwin_amd64。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-05-03-08.png" alt=""><br>将这个命令放到你的/usr/local/bin目录下，这样你就可以直接在命令行使用这个命令。并且我将qshell_darwin_amd64名字改成了qshell这样比较好记。后面可以参照七牛云的qshell使用手册来进行操作<a href="https://github.com/qiniu/qshell/wiki/qshell%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C" target="_blank" rel="external">https://github.com/qiniu/qshell/wiki/qshell%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C</a> 这里我只使用到了quplaod命令批量上传，首先我们要创建一个文件，最好是.json后缀的文件，例如我这里创建的是conf.json文件。<br><img src="http://opbae2xuz.bkt.clouddn.com/images/bhlin/2017-05-03-10.png" alt=""></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">这里简要说明一下：src_dir：</div><div class="line">   &quot;src_dir&quot;            :   &quot;本地上传的目录&quot;,</div><div class="line">   &quot;access_key&quot;         :   &quot;access_key， 在七牛云的个人中心秘钥管理查看&quot;,</div><div class="line">   &quot;secret_key&quot;         :   &quot;secret_key， 在七牛云的个人中心秘钥管理查看&quot;,</div><div class="line">   &quot;bucket&quot;             :   &quot;这里是上面创建存储空间的bucket&quot;,</div><div class="line">   &quot;up_host&quot;            :   &quot;http://up-z2.qiniu.com 不同地区的上传地址不同&quot;,</div><div class="line">   &quot;zone&quot;               :   &quot;hn 不同地区不同&quot;,</div><div class="line">   &quot;key_prefix&quot;         :   &quot;images/bhlin/ 文件上传后外链默认域名+这里设置的内容+图表名称，组成一个完整的外链&quot;,</div><div class="line">   &quot;ignore_dir&quot;			:	false,</div><div class="line">   &quot;skip_suffixes&quot;      :   &quot;.DS_Store  忽略文件后缀&quot;</div></pre></td></tr></table></figure>
<p>在conf.json中将这些文件配好了以后，通过下面的命令上传</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">qshell qupload ./config.json</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://r12f.com/posts/building-blog-with-hexo-and-github-pages/" target="_blank" rel="external">使用github pages和hexo搭建静态博客</a></li>
<li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo 文档</a></li>
<li><a href="https://github.com/qiniu/qshell?ref=developer.qiniu.com" target="_blank" rel="external">七牛云 qshell</a></li>
<li><a href="https://github.com/qiniu/qshell/wiki/qshell使用手册" target="_blank" rel="external">qshell使用手册</a></li>
<li><a href="https://pages.github.com/" target="_blank" rel="external">github pages网站</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pyenv搭建]]></title>
      <url>/2016/12/06/pyenv%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单来说pyenv是用来管理多个python版本的工具，使用起来简单方便。并且pyenv可以自己下载python并且进行管理，但是并不能添加已经下载好的python版本。</p>
<a id="more"></a>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>使用Homebrew进行安装pyenv:<br><code>brew install pyenv</code><br>如果出现以下错误，很有可能是你的xcodeTool没有安装：<br><code>zipimport.ZipImportError:can&#39;t decompress data; zlib not available</code><br>具体问题可以去<a href="https://github.com/yyuu/pyenv/issues/454" target="_blank" rel="external">github issuse</a>查看问题，可以通过以下命令安装xcodeTool：<br><code>xcode-select --install</code></p>
<p>安装成功后，向bash_profile中添加配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bash_profile</div><div class="line">$ echo &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bash_profile</div><div class="line">$ echo &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bash_profile</div></pre></td></tr></table></figure></p>
<p>添加后再重新加载shell<br><code>exec $SHELL -l</code></p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>查看当前使用的python版本<br><code>pyenv version</code></p>
<p>查看当前所有的python版本和当前使用的版本，带有<code>*</code>号表示正在使用的版本<br><code>pyenv versions</code></p>
<p>查看可以安装的python版本，会列出所有可以通过pyenv下载的python版本<br><code>pyenv install --list</code></p>
<p>下载安装python<br><code>pyenv install python版本</code></p>
<blockquote>
<p>对于比较大的版本文件，例如anaconda，可以先到官网下载，然后将文件放在~/.pyenv/cache目录下，再执行安装命令时，pyenv不会重复下载。</p>
</blockquote>
<p>卸载python版本<br><code>pyenv uninstall python版本</code></p>
<p>设置全局python版本<br><code>pyenv global python版本</code></p>
<p>设置局部python版本，在局部目录下会发现.python-version的一个文件，里面只有设置局部的版本号<br><code>pyenv local python版本</code></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jenv安装使用]]></title>
      <url>/2016/12/05/jenv%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="jenv介绍"><a href="#jenv介绍" class="headerlink" title="jenv介绍"></a>jenv介绍</h2><p>jenv相当于rbenv,但对于Java环境。它允许轻松地切换几个JDK环境,并配置每个项目使用哪一个版本的JDK，修改起来相当的方便快捷。(jenv、pyenv、rbenv类似)</p>
<a id="more"></a>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>首先通过Homebrew安装jenv：<code>brew install jenv</code><br>如果安装失败并发现找不到directory, 可以自己建立文件夹<br><figure class="highlight plain"><figcaption><span>~/.jenv</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/.jenv/</div><div class="line">mkdir versions</div></pre></td></tr></table></figure></p>
<p>安装成功后需要进行配置才可以让jenv起作用。<br>使用bash的情况<br><figure class="highlight plain"><figcaption><span>echo 'export PATH</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;eval &quot;$(jenv init -)&quot;&apos; &gt;&gt; ~/.bash_profile</div></pre></td></tr></table></figure></p>
<p>完成以上步骤，jenv就已经安装的差不多了，现在我们来看下当前jenv来管理的是哪个jdk的版本，输入以下命令查看当前jenv管理的所有jdk版本和当前的正在管理的jdk版本：<br><figure class="highlight plain"><figcaption><span>jenv versions</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* system (set by /Users/bxpeng/.jenv/version)</div><div class="line">``` </div><div class="line">你会发现只有一个system 并且前面有个`*`，这个`*`就是代表当前的jdk版本。jenv默认找到了系统默认的java。</div><div class="line">和pyenv不同的是，jenv并不能安装任何版本的jdk，需要我们手动下载安装jdk，然后再通过jenv来进行管理。</div><div class="line"></div><div class="line">安装[jdk6](https://support.apple.com/kb/DL1572?locale=zh_CN) 可以通过appstore进行下载安装，下载地址’https://support.apple.com/kb/DL1572?locale=zh_CN‘. jdk7可以在[oracle](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)官网进行下载。 安装路径都在`/Library/Java/JavaVirtualMachines/`下可以看到。</div><div class="line"></div><div class="line">使用`jenv add`命令来讲jdk加入到jenv中进行管理。</div><div class="line">```jenv add /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home/</div></pre></td></tr></table></figure></p>
<p>加入后再次查看jenv所管理的版本<br><figure class="highlight plain"><figcaption><span>jenv versions</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* system (set by /Users/bxpeng/.jenv/version)</div><div class="line">  1.6</div><div class="line">  1.6.0.65</div><div class="line">  oracle64-1.6.0.65</div></pre></td></tr></table></figure></p>
<p>其中1.6和1.6.0.65和oracle64-1.6.0.65是一样的，可以通过<code>jenv remove path</code> 来删除管理的版本<br><figure class="highlight plain"><figcaption><span>remove 1.6</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jenv remove oracle64-1.6.0.65</div><div class="line">``` </div><div class="line"></div><div class="line">后面继续添加jdk1.7、1.8等版本按照以上步骤就可以了，添加完jdk1.7、1.8后查看jenv管理的所有版本：</div><div class="line">```$ jenv versions</div><div class="line">* system (set by /Users/bxpeng/.jenv/version)</div><div class="line">  1.6.0.65</div><div class="line">  1.7.0.71</div><div class="line">  1.8.0.25</div></pre></td></tr></table></figure></p>
<p>然后通过<code>jenv global</code>设置默认的java 版本，也可以通过<code>jenv local</code>设置当前目录所使用的版本。<br>例如我们设置1.8.0.25为默认的jdk版本：<br><code>jenv global 1.8.0.25</code></p>
<p>如果我们设置<code>/User/bhlin/demo</code>这个文件夹里面为1.6.0.65版本的话：<br><figure class="highlight plain"><figcaption><span>/User/bhlin/demo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jenv local 1.6.0.65</div></pre></td></tr></table></figure></p>
<p>通过<code>jenv version</code>可以看到这个文件夹的jdk版本是1.6而不是1.8了</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Homebrew安装与使用]]></title>
      <url>/2016/11/26/Homebrew%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>简介<br><a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a>是MacOs下著名的包管理器，为软件包提供了非常方便的安装方式。Homebrew是根据ruby脚本来定义安装配置。<br>Homebrew中文装置<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">http://brew.sh/index_zh-cn.html</a></p>
<a id="more"></a>
<p>##安装<br>安装<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a>是非常简单的只需要打开命令行将下面这句话复制到命令行中运行。Homebrew 将本机的/usr/local/ 目录初始化为Git的工作树，并将目录所有者变更为当前用户，也就是你当前所操作的用户，所以以后的操作都不再需要sudo，这是安全的。后面安装的软件包放到/usr/local/Cellar/目录里面<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p>
<p>##删除<br>删除和安装一样方便也是将下面的命令复制到命令行运行即可<br><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</code></p>
<p>##使用</p>
<ul>
<li>查找软件包<br>  <code>brew search wget</code></li>
<li>安装软件包<br>  <code>brew install wget</code></li>
<li>查询已安装的软件包<br>  <code>brew list</code></li>
<li>删除软件包<br><code>brew remove wget</code></li>
<li>查看软件包信息<br><code>brew info wget</code></li>
<li>列出软件包的依赖关系<br><code>brew deps wget</code></li>
<li>列出过时的软件包<br><code>brew outdated</code></li>
<li>更新brew<br><code>brew update</code></li>
<li>查看哪些软件需要更新<br><code>brew outdated</code></li>
<li>更新过时的软件包（全部或指定）<br><code>brew upgrade</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
